{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Dispatch API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p> <p>Also checkout the high-level overview of the various api repositories and how they work together</p> <p>Dispatches might include, for example:</p> <ul> <li>Hard shutdown of a location or an individual microgrid component</li> <li>Charging or discharging a battery</li> <li>Activation or deactivation of balancing power</li> <li>Activation or deactivation of a power plant</li> </ul> <p>Microgrid controllers are expected to regularly query this API to keep up to date with what resources the cloud wishes them to deploy.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Dispatch API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/dispatch/v1/dispatch.proto</p> <ul> <li>ComponentIDs</li> <li>ComponentSelector</li> <li>Dispatch</li> <li>DispatchCreateRequest</li> <li>DispatchDeleteRequest</li> <li>DispatchFilter</li> <li>DispatchGetRequest</li> <li>DispatchList</li> <li>DispatchListRequest</li> <li>DispatchUpdateRequest</li> <li>DispatchUpdateRequest.DispatchUpdate</li> <li>DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate</li> <li>RecurrenceRule</li> <li>RecurrenceRule.EndCriteria</li> <li> <p>TimeIntervalFilter</p> </li> <li> <p>RecurrenceRule.Frequency</p> </li> <li> <p>RecurrenceRule.Weekday</p> </li> <li> <p>MicrogridDispatchService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#frequenzapidispatchv1dispatchproto","title":"frequenz/api/dispatch/v1/dispatch.proto","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#componentids","title":"ComponentIDs","text":"<p>Wrapper for controlling dispatches with a set of component IDs</p> Field Type Label Description component_ids uint64 repeated Set of component IDs <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#componentselector","title":"ComponentSelector","text":"<p>Parameter for controlling which components a dispatch applies to either a set of component IDs, or all components belonging to a category.</p> <p>When specifying a set of IDs, all IDs should have the same component category, mixing components from different categories in one dispatch message is not supported.</p> Field Type Label Description component_ids ComponentIDs Set of component IDs component_category frequenz.api.common.v1.microgrid.components.ComponentCategory Component category <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatch","title":"Dispatch","text":"<p>Message representing one dispatch.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> Field Type Label Description id uint64 The dispatch identifier microgrid_id uint64 The microgrid identifier type string The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field. create_time google.protobuf.Timestamp The creation time in UTC This is set when a dispatch is created via the create request message update_time google.protobuf.Timestamp The update time in UTC This is set when a dispatch is modified via the update request message start_time google.protobuf.Timestamp The start time in UTC duration uint32 Duration in seconds selector ComponentSelector The component selector is_active bool The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion. is_dry_run bool The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes. payload google.protobuf.Struct The dispatch payload recurrence RecurrenceRule The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchcreaterequest","title":"DispatchCreateRequest","text":"<p>Message to create a new dispatch with the given attributes</p> Field Type Label Description microgrid_id uint64 The microgrid identifier type string The type of dispatch start_time google.protobuf.Timestamp The start time When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. duration uint32 Duration in seconds selector ComponentSelector The component selector is_active bool The \"active\" status is_dry_run bool The \"dry run\" status payload google.protobuf.Struct The dispatch payload recurrence RecurrenceRule The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchdeleterequest","title":"DispatchDeleteRequest","text":"<p>Message to delete a single dispatch by its ID</p> Field Type Label Description id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchfilter","title":"DispatchFilter","text":"<p>Parameters for filtering the dispatch list</p> Field Type Label Description selectors ComponentSelector repeated Filter by component ID or category time_interval TimeIntervalFilter Filter by time interval If no interval is provided, all dispatches starting from the current timestamp will be included. is_active bool optional Filter by active status If this field is not set, dispatches of any active status will be included. is_dry_run bool optional Filter by dry run status If this field is not set, dispatches of any dry run status will be included. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchgetrequest","title":"DispatchGetRequest","text":"<p>Message to get a single dispatch by its ID</p> Field Type Label Description id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchlist","title":"DispatchList","text":"<p>A list of dispatches</p> Field Type Label Description dispatches Dispatch repeated The dispatches <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchlistrequest","title":"DispatchListRequest","text":"<p>Message for listing dispatches for a given microgrid, and an optional filter</p> Field Type Label Description microgrid_id uint64 The microgrid ID filter DispatchFilter Additional filter parameters <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchupdaterequest","title":"DispatchUpdateRequest","text":"<p>Message to update the dispatch with the given ID, with the given attributes</p> Field Type Label Description id uint64 The dispatch identifier update_mask google.protobuf.FieldMask Field mask specifying which fields should be updated update DispatchUpdateRequest.DispatchUpdate The updated dispatch attributes <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchupdaterequestdispatchupdate","title":"DispatchUpdateRequest.DispatchUpdate","text":"<p>Message containing the updated dispatch attributes</p> Field Type Label Description type string optional The type of dispatch start_time google.protobuf.Timestamp The start time When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. duration uint32 optional Duration in seconds selector ComponentSelector The component selector is_active bool optional The \"active\" status is_dry_run bool optional The \"dry run\" status payload google.protobuf.Struct The dispatch payload recurrence DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchupdaterequestdispatchupdaterecurrenceruleupdate","title":"DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate","text":"<p>Message containing the updated recurrence rule attributes</p> Field Type Label Description freq RecurrenceRule.Frequency optional The frequency specifier of this recurring dispatch interval uint32 optional How often this dispatch should recur, based on the frequency end_criteria RecurrenceRule.EndCriteria When this dispatch should end. byminutes uint32 repeated On which minute(s) of the hour does the event occur byhours uint32 repeated On which hour(s) of the day does the event occur byweekdays RecurrenceRule.Weekday repeated On which day(s) of the week does the event occur bymonthdays uint32 repeated On which day(s) of the month does the event occur bymonths uint32 repeated On which month(s) of the year does the event occur <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrencerule","title":"RecurrenceRule","text":"<p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC5545.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#examples","title":"Examples","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#every-6-months","title":"Every 6 months","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#weekends-only","title":"Weekends only","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#at-midnight","title":"At midnight","text":"<p>Every day at midnight.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#nightly","title":"Nightly","text":"<p>Assuming \"night\" means from 8 PM to 6 AM.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre> Field Type Label Description freq RecurrenceRule.Frequency The frequency specifier of this recurring dispatch interval uint32 How often this dispatch should recur, based on the frequency Example: - Every 2 hours: freq = FREQUENCY_HOURLY interval = 2 end_criteria RecurrenceRule.EndCriteria When this dispatch should end. A dispatch can either recur a fixed number of times, or until a given timestamp. If this field is not set, the dispatch will recur indefinitely.bool byminutes uint32 repeated On which minute(s) of the hour does the event occur byhours uint32 repeated On which hour(s) of the day does the event occur byweekdays RecurrenceRule.Weekday repeated On which day(s) of the week does the event occur bymonthdays uint32 repeated On which day(s) of the month does the event occur bymonths uint32 repeated On which month(s) of the year does the event occur <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrenceruleendcriteria","title":"RecurrenceRule.EndCriteria","text":"<p>Controls when a recurring dispatch should end</p> Field Type Label Description count uint32 The number of times this dispatch should recur. If this field is set, the dispatch will recur the given number of times. until google.protobuf.Timestamp The end time of this dispatch in UTC. If this field is set, the dispatch will recur until the given timestamp. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#timeintervalfilter","title":"TimeIntervalFilter","text":"<p>Filter parameter for specifying multiple time intervals</p> Field Type Label Description start_from google.protobuf.Timestamp Filter by start_time &gt;= this timestamp start_to google.protobuf.Timestamp Filter by start_time &lt; this timestamp end_from google.protobuf.Timestamp Filter by recurrence.end_criteria.until &gt;= this timestamp end_to google.protobuf.Timestamp Filter by recurrence.end_criteria.until &lt; this timestamp <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrencerulefrequency","title":"RecurrenceRule.Frequency","text":"<p>Enum representing the frequency of the recurrence</p> Name Number Description FREQUENCY_UNSPECIFIED 0 FREQUENCY_MINUTELY 1 FREQUENCY_HOURLY 2 FREQUENCY_DAILY 3 FREQUENCY_WEEKLY 4 FREQUENCY_MONTHLY 5 <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrenceruleweekday","title":"RecurrenceRule.Weekday","text":"<p>Enum representing the day of the week</p> Name Number Description WEEKDAY_UNSPECIFIED 0 WEEKDAY_MONDAY 1 WEEKDAY_TUESDAY 2 WEEKDAY_WEDNESDAY 3 WEEKDAY_THURSDAY 4 WEEKDAY_FRIDAY 5 WEEKDAY_SATURDAY 6 WEEKDAY_SUNDAY 7 <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#microgriddispatchservice","title":"MicrogridDispatchService","text":"<p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to    support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p> Method Name Request Type Response Type Description ListMicrogridDispatches DispatchListRequest DispatchList Returns a list of all dispatches CreateMicrogridDispatch DispatchCreateRequest .google.protobuf.Empty Create a new dispatch UpdateMicrogridDispatch DispatchUpdateRequest .google.protobuf.Empty Update a dispatch GetMicrogridDispatch DispatchGetRequest Dispatch Get a single dispatch DeleteMicrogridDispatch DispatchDeleteRequest .google.protobuf.Empty Delete a given dispatch"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch_pb2</li> <li>dispatch_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/","title":"Index","text":""},{"location":"python-reference/frequenz/api/dispatch/#frequenz.api.dispatch","title":"frequenz.api.dispatch","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/","title":"Index","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/#frequenz.api.dispatch.v1","title":"frequenz.api.dispatch.v1","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/","title":"dispatch_pb2","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2","title":"frequenz.api.dispatch.v1.dispatch_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentIDs","title":"frequenz.api.dispatch.v1.dispatch_pb2.ComponentIDs","text":"<p>               Bases: <code>Message</code></p> <p>Wrapper for controlling dispatches with a set of component IDs</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentIDs-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentIDs.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: RepeatedScalarFieldContainer[int]\n</code></pre> <p>Set of component IDs</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentSelector","title":"frequenz.api.dispatch.v1.dispatch_pb2.ComponentSelector","text":"<p>               Bases: <code>Message</code></p> <p>Parameter for controlling which components a dispatch applies to either a set of component IDs, or all components belonging to a category.</p> <p>When specifying a set of IDs, all IDs should have the same component category, mixing components from different categories in one dispatch message is not supported.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentSelector-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentSelector.component_category","title":"component_category  <code>instance-attribute</code>","text":"<pre><code>component_category: ValueType\n</code></pre> <p>Component category</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ComponentSelector.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: global___ComponentIDs\n</code></pre> <p>Set of component IDs</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch","title":"frequenz.api.dispatch.v1.dispatch_pb2.Dispatch","text":"<p>               Bases: <code>Message</code></p> <p>Message representing one dispatch.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2.py</code> <pre><code>  _globals['_COMPONENTSELECTOR']._serialized_start=896\n  _globals['_COMPONENTSELECTOR']._serialized_end=1086\n  _globals['_COMPONENTIDS']._serialized_start=1088\n  _globals['_COMPONENTIDS']._serialized_end=1125\n  _globals['_RECURRENCERULE']._serialized_start=1128\n  _globals['_RECURRENCERULE']._serialized_end=1882\n  _globals['_RECURRENCERULE_ENDCRITERIA']._serialized_start=1451\n  _globals['_RECURRENCERULE_ENDCRITERIA']._serialized_end=1544\n  _globals['_RECURRENCERULE_WEEKDAY']._serialized_start=1547\n  _globals['_RECURRENCERULE_WEEKDAY']._serialized_end=1729\n  _globals['_RECURRENCERULE_FREQUENCY']._serialized_start=1732\n  _globals['_RECURRENCERULE_FREQUENCY']._serialized_end=1882\n  _globals['_DISPATCHLISTREQUEST']._serialized_start=1884\n  _globals['_DISPATCHLISTREQUEST']._serialized_end=1985\n  _globals['_DISPATCHFILTER']._serialized_start=1988\n  _globals['_DISPATCHFILTER']._serialized_end=2215\n  _globals['_DISPATCHLIST']._serialized_start=2217\n  _globals['_DISPATCHLIST']._serialized_end=2287\n  _globals['_DISPATCHCREATEREQUEST']._serialized_start=2290\n  _globals['_DISPATCHCREATEREQUEST']._serialized_end=2621\n  _globals['_DISPATCHUPDATEREQUEST']._serialized_start=2624\n  _globals['_DISPATCHUPDATEREQUEST']._serialized_end=3569\n  _globals['_DISPATCHUPDATEREQUEST_DISPATCHUPDATE']._serialized_start=2791\n  _globals['_DISPATCHUPDATEREQUEST_DISPATCHUPDATE']._serialized_end=3569\n  _globals['_DISPATCHUPDATEREQUEST_DISPATCHUPDATE_RECURRENCERULEUPDATE']._serialized_start=3159\n  _globals['_DISPATCHUPDATEREQUEST_DISPATCHUPDATE_RECURRENCERULEUPDATE']._serialized_end=3518\n  _globals['_DISPATCHGETREQUEST']._serialized_start=3571\n  _globals['_DISPATCHGETREQUEST']._serialized_end=3603\n  _globals['_DISPATCHDELETEREQUEST']._serialized_start=3605\n  _globals['_DISPATCHDELETEREQUEST']._serialized_end=3640\n  _globals['_MICROGRIDDISPATCHSERVICE']._serialized_start=3643\n  _globals['_MICROGRIDDISPATCHSERVICE']._serialized_end=4189\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.create_time","title":"create_time  <code>property</code>","text":"<pre><code>create_time: Timestamp\n</code></pre> <p>The creation time in UTC This is set when a dispatch is created via the create request message</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: int\n</code></pre> <p>Duration in seconds</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.is_active","title":"is_active  <code>instance-attribute</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.is_dry_run","title":"is_dry_run  <code>instance-attribute</code>","text":"<pre><code>is_dry_run: bool\n</code></pre> <p>The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: Struct\n</code></pre> <p>The dispatch payload</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.recurrence","title":"recurrence  <code>property</code>","text":"<pre><code>recurrence: global___RecurrenceRule\n</code></pre> <p>The recurrence rule</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.selector","title":"selector  <code>property</code>","text":"<pre><code>selector: global___ComponentSelector\n</code></pre> <p>The component selector</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.start_time","title":"start_time  <code>property</code>","text":"<pre><code>start_time: Timestamp\n</code></pre> <p>The start time in UTC</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.update_time","title":"update_time  <code>property</code>","text":"<pre><code>update_time: Timestamp\n</code></pre> <p>The update time in UTC This is set when a dispatch is modified via the update request message</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to create a new dispatch with the given attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: int\n</code></pre> <p>Duration in seconds</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.is_active","title":"is_active  <code>instance-attribute</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>The \"active\" status</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.is_dry_run","title":"is_dry_run  <code>instance-attribute</code>","text":"<pre><code>is_dry_run: bool\n</code></pre> <p>The \"dry run\" status</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: Struct\n</code></pre> <p>The dispatch payload</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.recurrence","title":"recurrence  <code>property</code>","text":"<pre><code>recurrence: global___RecurrenceRule\n</code></pre> <p>The recurrence rule</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.selector","title":"selector  <code>property</code>","text":"<pre><code>selector: global___ComponentSelector\n</code></pre> <p>The component selector</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.start_time","title":"start_time  <code>property</code>","text":"<pre><code>start_time: Timestamp\n</code></pre> <p>The start time When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchCreateRequest.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>The type of dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchDeleteRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchDeleteRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to delete a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchDeleteRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchDeleteRequest.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter","text":"<p>               Bases: <code>Message</code></p> <p>Parameters for filtering the dispatch list</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.is_active","title":"is_active  <code>instance-attribute</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>Filter by active status If this field is not set, dispatches of any active status will be included.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.is_dry_run","title":"is_dry_run  <code>instance-attribute</code>","text":"<pre><code>is_dry_run: bool\n</code></pre> <p>Filter by dry run status If this field is not set, dispatches of any dry run status will be included.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.selectors","title":"selectors  <code>property</code>","text":"<pre><code>selectors: RepeatedCompositeFieldContainer[\n    global___ComponentSelector\n]\n</code></pre> <p>Filter by component ID or category</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.time_interval","title":"time_interval  <code>property</code>","text":"<pre><code>time_interval: global___TimeIntervalFilter\n</code></pre> <p>Filter by time interval If no interval is provided, all dispatches starting from the current timestamp will be included.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchGetRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchGetRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to get a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchGetRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchGetRequest.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchList","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchList","text":"<p>               Bases: <code>Message</code></p> <p>A list of dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchList-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchList.dispatches","title":"dispatches  <code>property</code>","text":"<pre><code>dispatches: RepeatedCompositeFieldContainer[\n    global___Dispatch\n]\n</code></pre> <p>The dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchListRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchListRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message for listing dispatches for a given microgrid, and an optional filter</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchListRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchListRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___DispatchFilter\n</code></pre> <p>Additional filter parameters</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchListRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to update the dispatch with the given ID, with the given attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.update","title":"update  <code>property</code>","text":"<pre><code>update: DispatchUpdate\n</code></pre> <p>The updated dispatch attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.update_mask","title":"update_mask  <code>property</code>","text":"<pre><code>update_mask: FieldMask\n</code></pre> <p>Field mask specifying which fields should be updated</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.DispatchUpdate","title":"DispatchUpdate","text":"<p>               Bases: <code>Message</code></p> <p>Message containing the updated dispatch attributes</p> Attributes\u00a4 duration <code>instance-attribute</code> \u00a4 <pre><code>duration: int\n</code></pre> <p>Duration in seconds</p> is_active <code>instance-attribute</code> \u00a4 <pre><code>is_active: bool\n</code></pre> <p>The \"active\" status</p> is_dry_run <code>instance-attribute</code> \u00a4 <pre><code>is_dry_run: bool\n</code></pre> <p>The \"dry run\" status</p> payload <code>property</code> \u00a4 <pre><code>payload: Struct\n</code></pre> <p>The dispatch payload</p> recurrence <code>property</code> \u00a4 <pre><code>recurrence: RecurrenceRuleUpdate\n</code></pre> <p>The recurrence rule</p> selector <code>property</code> \u00a4 <pre><code>selector: global___ComponentSelector\n</code></pre> <p>The component selector</p> start_time <code>property</code> \u00a4 <pre><code>start_time: Timestamp\n</code></pre> <p>The start time When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p> type <code>instance-attribute</code> \u00a4 <pre><code>type: str\n</code></pre> <p>The type of dispatch</p> Classes\u00a4 RecurrenceRuleUpdate \u00a4 <p>               Bases: <code>Message</code></p> <p>Message containing the updated recurrence rule attributes</p> Attributes\u00a4 byhours <code>property</code> \u00a4 <pre><code>byhours: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which hour(s) of the day does the event occur</p> byminutes <code>property</code> \u00a4 <pre><code>byminutes: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which minute(s) of the hour does the event occur</p> bymonthdays <code>property</code> \u00a4 <pre><code>bymonthdays: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which day(s) of the month does the event occur</p> bymonths <code>property</code> \u00a4 <pre><code>bymonths: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which month(s) of the year does the event occur</p> byweekdays <code>property</code> \u00a4 <pre><code>byweekdays: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>On which day(s) of the week does the event occur</p> end_criteria <code>property</code> \u00a4 <pre><code>end_criteria: EndCriteria\n</code></pre> <p>When this dispatch should end.</p> freq <code>instance-attribute</code> \u00a4 <pre><code>freq: ValueType\n</code></pre> <p>The frequency specifier of this recurring dispatch</p> interval <code>instance-attribute</code> \u00a4 <pre><code>interval: int\n</code></pre> <p>How often this dispatch should recur, based on the frequency</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule","title":"frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule","text":"<p>               Bases: <code>Message</code></p> <p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC5545.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--examples","title":"Examples","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--every-6-months","title":"Every 6 months","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--weekends-only","title":"Weekends only","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--at-midnight","title":"At midnight","text":"<p>Every day at midnight.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--nightly","title":"Nightly","text":"<p>Assuming \"night\" means from 8 PM to 6 AM.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byhours","title":"byhours  <code>property</code>","text":"<pre><code>byhours: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which hour(s) of the day does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byminutes","title":"byminutes  <code>property</code>","text":"<pre><code>byminutes: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which minute(s) of the hour does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonthdays","title":"bymonthdays  <code>property</code>","text":"<pre><code>bymonthdays: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which day(s) of the month does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonths","title":"bymonths  <code>property</code>","text":"<pre><code>bymonths: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which month(s) of the year does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byweekdays","title":"byweekdays  <code>property</code>","text":"<pre><code>byweekdays: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>On which day(s) of the week does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.end_criteria","title":"end_criteria  <code>property</code>","text":"<pre><code>end_criteria: EndCriteria\n</code></pre> <p>When this dispatch should end. A dispatch can either recur a fixed number of times, or until a given timestamp. If this field is not set, the dispatch will recur indefinitely.bool</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.freq","title":"freq  <code>instance-attribute</code>","text":"<pre><code>freq: ValueType\n</code></pre> <p>The frequency specifier of this recurring dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.interval","title":"interval  <code>instance-attribute</code>","text":"<pre><code>interval: int\n</code></pre> <p>How often this dispatch should recur, based on the frequency Example: - Every 2 hours:   freq = FREQUENCY_HOURLY   interval = 2</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.EndCriteria","title":"EndCriteria","text":"<p>               Bases: <code>Message</code></p> <p>Controls when a recurring dispatch should end</p> Attributes\u00a4 count <code>instance-attribute</code> \u00a4 <pre><code>count: int\n</code></pre> <p>The number of times this dispatch should recur. If this field is set, the dispatch will recur the given number of times.</p> until <code>property</code> \u00a4 <pre><code>until: Timestamp\n</code></pre> <p>The end time of this dispatch in UTC. If this field is set, the dispatch will recur until the given timestamp.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.Frequency","title":"Frequency","text":"<p>               Bases: <code>_Frequency</code></p> <p>Enum representing the frequency of the recurrence</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.Weekday","title":"Weekday","text":"<p>               Bases: <code>_Weekday</code></p> <p>Enum representing the day of the week</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter","title":"frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter","text":"<p>               Bases: <code>Message</code></p> <p>Filter parameter for specifying multiple time intervals</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter.end_from","title":"end_from  <code>property</code>","text":"<pre><code>end_from: Timestamp\n</code></pre> <p>Filter by recurrence.end_criteria.until &gt;= this timestamp</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter.end_to","title":"end_to  <code>property</code>","text":"<pre><code>end_to: Timestamp\n</code></pre> <p>Filter by recurrence.end_criteria.until &lt; this timestamp</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter.start_from","title":"start_from  <code>property</code>","text":"<pre><code>start_from: Timestamp\n</code></pre> <p>Filter by start_time &gt;= this timestamp</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter.start_to","title":"start_to  <code>property</code>","text":"<pre><code>start_to: Timestamp\n</code></pre> <p>Filter by start_time &lt; this timestamp</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/","title":"dispatch_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchService(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n    \"\"\"\n\n    @staticmethod\n    def ListMicrogridDispatches(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def CreateMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def UpdateMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def GetMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def DeleteMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub","text":"<p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to    support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>                _registered_method=True)\n        self.DeleteMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                _registered_method=True)\n\n\nclass MicrogridDispatchServiceServicer(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n    \"\"\"\n\n    def ListMicrogridDispatches(self, request, context):\n        \"\"\"Returns a list of all dispatches\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CreateMicrogridDispatch(self, request, context):\n        \"\"\"Create a new dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def UpdateMicrogridDispatch(self, request, context):\n        \"\"\"Update a dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.CreateMicrogridDispatch","title":"CreateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>CreateMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchCreateRequest, Empty\n]\n</code></pre> <p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>DeleteMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchDeleteRequest, Empty\n]\n</code></pre> <p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.GetMicrogridDispatch","title":"GetMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>GetMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchGetRequest, Dispatch\n]\n</code></pre> <p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.ListMicrogridDispatches","title":"ListMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>ListMicrogridDispatches: UnaryUnaryMultiCallable[\n    DispatchListRequest, DispatchList\n]\n</code></pre> <p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>UpdateMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchUpdateRequest, Empty\n]\n</code></pre> <p>Update a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceServicer(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n    \"\"\"\n\n    def ListMicrogridDispatches(self, request, context):\n        \"\"\"Returns a list of all dispatches\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CreateMicrogridDispatch(self, request, context):\n        \"\"\"Create a new dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def UpdateMicrogridDispatch(self, request, context):\n        \"\"\"Update a dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def GetMicrogridDispatch(self, request, context):\n        \"\"\"Get a single dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def DeleteMicrogridDispatch(self, request, context):\n        \"\"\"Delete a given dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.CreateMicrogridDispatch","title":"CreateMicrogridDispatch","text":"<pre><code>CreateMicrogridDispatch(\n    request: DispatchCreateRequest,\n    context: _ServicerContext,\n) -&gt; Union[Empty, Awaitable[Empty]]\n</code></pre> <p>Create a new dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def CreateMicrogridDispatch(self, request, context):\n    \"\"\"Create a new dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch","text":"<pre><code>DeleteMicrogridDispatch(\n    request: DispatchDeleteRequest,\n    context: _ServicerContext,\n) -&gt; Union[Empty, Awaitable[Empty]]\n</code></pre> <p>Delete a given dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def DeleteMicrogridDispatch(self, request, context):\n    \"\"\"Delete a given dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.GetMicrogridDispatch","title":"GetMicrogridDispatch","text":"<pre><code>GetMicrogridDispatch(\n    request: DispatchGetRequest, context: _ServicerContext\n) -&gt; Union[Dispatch, Awaitable[Dispatch]]\n</code></pre> <p>Get a single dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def GetMicrogridDispatch(self, request, context):\n    \"\"\"Get a single dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.ListMicrogridDispatches","title":"ListMicrogridDispatches","text":"<pre><code>ListMicrogridDispatches(\n    request: DispatchListRequest, context: _ServicerContext\n) -&gt; Union[DispatchList, Awaitable[DispatchList]]\n</code></pre> <p>Returns a list of all dispatches</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def ListMicrogridDispatches(self, request, context):\n    \"\"\"Returns a list of all dispatches\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch","text":"<pre><code>UpdateMicrogridDispatch(\n    request: DispatchUpdateRequest,\n    context: _ServicerContext,\n) -&gt; Union[Empty, Awaitable[Empty]]\n</code></pre> <p>Update a dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def UpdateMicrogridDispatch(self, request, context):\n    \"\"\"Update a dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceStub(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.ListMicrogridDispatches = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\n                _registered_method=True)\n        self.CreateMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                _registered_method=True)\n        self.UpdateMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                _registered_method=True)\n        self.GetMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\n                _registered_method=True)\n        self.DeleteMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.CreateMicrogridDispatch","title":"CreateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>CreateMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchCreateRequest, Empty\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>DeleteMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchDeleteRequest, Empty\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.GetMicrogridDispatch","title":"GetMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>GetMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchGetRequest, Dispatch\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.ListMicrogridDispatches","title":"ListMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>ListMicrogridDispatches: UnaryUnaryMultiCallable[\n    DispatchListRequest, DispatchList\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>UpdateMicrogridDispatch: UnaryUnaryMultiCallable[\n    DispatchUpdateRequest, Empty\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Update a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.__init__","title":"__init__","text":"<pre><code>__init__(channel: Union[Channel, Channel]) -&gt; None\n</code></pre> <p>Constructor.</p> PARAMETER DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.ListMicrogridDispatches = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\n            _registered_method=True)\n    self.CreateMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            _registered_method=True)\n    self.UpdateMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            _registered_method=True)\n    self.GetMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\n            _registered_method=True)\n    self.DeleteMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            _registered_method=True)\n</code></pre>"}]}