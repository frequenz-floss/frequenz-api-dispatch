{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Dispatch API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p> <p>Also checkout the high-level overview of the various api repositories and how they work together</p> <p>Dispatches might include, for example:</p> <ul> <li>Hard shutdown of a location or an individual microgrid component</li> <li>Charging or discharging a battery</li> <li>Activation or deactivation of balancing power</li> <li>Activation or deactivation of a power plant</li> </ul> <p>Microgrid controllers are expected to regularly query this API to keep up to date with what resources the cloud wishes them to deploy.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Dispatch API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/dispatch/v1/dispatch.proto</p> <ul> <li>CreateMicrogridDispatchRequest</li> <li>CreateMicrogridDispatchResponse</li> <li>DeleteMicrogridDispatchRequest</li> <li>DeleteMicrogridDispatchResponse</li> <li>Dispatch</li> <li>DispatchData</li> <li>DispatchFilter</li> <li>DispatchFilter.RecurrenceFilter</li> <li>DispatchMetadata</li> <li>GetMicrogridDispatchRequest</li> <li>GetMicrogridDispatchResponse</li> <li>ListMicrogridDispatchesRequest</li> <li>ListMicrogridDispatchesResponse</li> <li>RecurrenceRule</li> <li>RecurrenceRule.EndCriteria</li> <li>SortOptions</li> <li>StreamMicrogridDispatchesRequest</li> <li>StreamMicrogridDispatchesResponse</li> <li>TargetComponents</li> <li>TargetComponents.CategorySet</li> <li>TargetComponents.IdSet</li> <li>TimeIntervalFilter</li> <li>UpdateMicrogridDispatchRequest</li> <li>UpdateMicrogridDispatchRequest.DispatchUpdate</li> <li>UpdateMicrogridDispatchRequest.DispatchUpdate.RecurrenceRuleUpdate</li> <li> <p>UpdateMicrogridDispatchResponse</p> </li> <li> <p>RecurrenceRule.Frequency</p> </li> <li>RecurrenceRule.Weekday</li> <li>SortField</li> <li>SortOrder</li> <li> <p>StreamMicrogridDispatchesResponse.Event</p> </li> <li> <p>MicrogridDispatchService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#frequenzapidispatchv1dispatchproto","title":"frequenz/api/dispatch/v1/dispatch.proto","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#createmicrogriddispatchrequest","title":"CreateMicrogridDispatchRequest","text":"<p>Message to create a new dispatch with the given attributes</p> Field Type Label Description microgrid_id uint64 The microgrid identifier dispatch_data DispatchData Content of the dispatch to be created <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#createmicrogriddispatchresponse","title":"CreateMicrogridDispatchResponse","text":"<p>Response message for creating a new dispatch</p> Field Type Label Description dispatch Dispatch The created dispatch <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#deletemicrogriddispatchrequest","title":"DeleteMicrogridDispatchRequest","text":"<p>Message to delete a single dispatch by its ID</p> Field Type Label Description microgrid_id uint64 The microgrid ID that the dispatch belongs to dispatch_id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#deletemicrogriddispatchresponse","title":"DeleteMicrogridDispatchResponse","text":"<p>Response message for deleting a single dispatch</p> Field Type Label Description microgrid_id uint64 The microgrid ID that the dispatch belonged to dispatch_id uint64 The dispatch ID that was deleted <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatch","title":"Dispatch","text":"<p>Represents a dispatch, including its metadata</p> Field Type Label Description metadata DispatchMetadata Dispatch Metadata (id, create time, etc) data DispatchData The dispatch data <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchdata","title":"DispatchData","text":"<p>Represents a dispatches data, including its type, start time, duration, and target components.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> Field Type Label Description type string The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field. start_time google.protobuf.Timestamp The dispatch start time in UTC. For reoccuring dispatches this is when the first time execution occurs. When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. duration uint32 optional Duration in seconds The duration of the dispatch in seconds. If the duration is not set, the dispatch will be considered to have an infinite duration. A duration of 0 seconds is also valid, indicating a dispatch that immediately starts and ends, e.g. switching a component on and off. target TargetComponents The components this dispatch should apply to. is_active bool The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion. is_dry_run bool The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes. payload google.protobuf.Struct The dispatch payload. <p>Note!!! The payload field allows for flexible JSON data to be associated with this dispatch. The payload must adhere to the following constraints: - Maximum JSON nesting depth: 5 levels. - The data should not contain executable code or scripts. - Ensure all data is properly sanitized and encoded. - The total size of the payload should not exceed 50 KB. | | recurrence | RecurrenceRule |  | The recurrence rule |</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchfilter","title":"DispatchFilter","text":"<p>Parameters for filtering the dispatch list</p> Field Type Label Description targets TargetComponents repeated Optional filter by component ID or category. is_active bool optional Optional filter by active status. If this field is not set, dispatches of any active status will be included. is_dry_run bool optional Optional filter by dry run status. If this field is not set, dispatches of any dry run status will be included. is_recurring bool Filter by recurring status True: Only recurring dispatches will be returned. False: Only non-recurring dispatches will be returned. Examples: - To retrieve only recurring dispatches: filter { recurrence { is_recurring: true } } - To retrieve only non-recurring dispatches: filter { recurrence { is_recurring: false } } - To retrieve all dispatches: filter { recurrence {} } For advanced recurrence filtering, use the <code>filter</code> field. filter DispatchFilter.RecurrenceFilter Filter by recurrence details Examples: - To retrieve only recurring dispatches with a specific frequency: filter { recurrence { filter { freq: FREQUENCY_DAILY } } } - To retrieve recurring dispatches with a specific frequency and interval: filter { recurrence { filter { freq: FREQUENCY_HOURLY, interval: 2 } } } - To retrieve recurring dispatches that end after a specific criteria: filter { recurrence { filter { end_criteria: { count: 10 } } } } - To retrieve recurring dispatches at specific minutes of the hour: filter { recurrence { filter { byminutes: [0, 15, 30, 45] } } } - To retrieve recurring dispatches at specific hours of the day: filter { recurrence { filter { byhours: [8, 12, 16] } } } - To retrieve recurring dispatches on specific days of the week: filter { recurrence { filter { byweekdays: [WEEKDAY_MONDAY, WEEKDAY_WEDNESDAY] } } } - To retrieve recurring dispatches on specific days of the month: filter { recurrence { filter { bymonthdays: [1, 15, 30, -1] } } } - To retrieve recurring dispatches in specific months of the year: filter { recurrence { filter { bymonths: [1, 6, 12] } } } start_time_interval TimeIntervalFilter Optional filter by start time. If no interval is provided, all dispatches will be returned. end_time_interval TimeIntervalFilter Optional filter by end time Filter dispatches based on their explicit end time. update_time_interval TimeIntervalFilter Optional filter by update time <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchfilterrecurrencefilter","title":"DispatchFilter.RecurrenceFilter","text":"<p>Recurrence filters</p> <p>The fields are left commented out for now as the exact definition and requirements for recurrence filtering are still being finalized.</p> <p>The frequency specifier of this recurring dispatch optional RecurrenceRule.Frequency freq = 1;</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#dispatchmetadata","title":"DispatchMetadata","text":"<p>Represents the metadata of a dispatch</p> Field Type Label Description dispatch_id uint64 Unique identifier of the microgrid dispatch. create_time google.protobuf.Timestamp UTC Timestamp when the order was created. modification_time google.protobuf.Timestamp UTC Timestamp of the last update to the order. end_time google.protobuf.Timestamp UTC Timestamp when the dispatch will stop working. Will be calculated internally based on the given: start_time, duration and RecurenceRule None if dispatch duration time is infinite and this value can't be calculated. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#getmicrogriddispatchrequest","title":"GetMicrogridDispatchRequest","text":"<p>Message to get a single dispatch by its ID</p> Field Type Label Description microgrid_id uint64 The microgrid ID that the dispatch belongs to dispatch_id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#getmicrogriddispatchresponse","title":"GetMicrogridDispatchResponse","text":"<p>Response message for getting a single dispatch</p> Field Type Label Description microgrid_id uint64 The microgrid ID that the dispatch belongs to dispatch Dispatch The dispatch <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#listmicrogriddispatchesrequest","title":"ListMicrogridDispatchesRequest","text":"<p>Message for listing dispatches for a given microgrid.</p> <p>Allows retrieval of dispatches for a specified microgrid with optional filtering and sorting. Sorting can be specified by setting 'sort_field' and 'sort_order'. If no sorting is specified, the results will be returned by their create time in a descending order.</p> Field Type Label Description microgrid_id uint64 The microgrid ID filter DispatchFilter Optional filters to apply sort_options SortOptions Sorting options for the result pagination_params frequenz.api.common.v1.pagination.PaginationParams Pagination Parameters page_size: Amount of items to return per page. Should only be provided in the first request. page_token: Cursor to specify which page to return. Should not be set in the first request. Should be populated in subsequent requests by the <code>next_page_token</code> found in the <code>pagination_info</code> in the response. The tokens stays valid indefinitely. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#listmicrogriddispatchesresponse","title":"ListMicrogridDispatchesResponse","text":"<p>A list of dispatches</p> Field Type Label Description dispatches Dispatch repeated The dispatches pagination_info frequenz.api.common.v1.pagination.PaginationInfo Pagination Info total_items: Total amount of entries found by the list request. next_page_token: Token that can be used to request the next page. Will be unset if no further pages exist. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrencerule","title":"RecurrenceRule","text":"<p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC5545.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#examples","title":"Examples","text":""},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#every-6-months","title":"Every 6 months","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#weekends-only","title":"Weekends only","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#at-midnight","title":"At midnight","text":"<p>Every day at midnight.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#nightly","title":"Nightly","text":"<p>Assuming \"night\" means from 8 PM to 6 AM.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre> Field Type Label Description freq RecurrenceRule.Frequency The frequency specifier of this recurring dispatch interval uint32 How often this dispatch should recur, based on the frequency Example: - Every 2 hours: freq = FREQUENCY_HOURLY interval = 2 Valid values typically range between 1 and 10_000, depending on the implementation. end_criteria RecurrenceRule.EndCriteria When this dispatch should end. A dispatch can either recur a fixed number of times, or until a given timestamp. If this field is not set, the dispatch will recur indefinitely. byminutes uint32 repeated On which minute(s) of the hour does the event occur byhours uint32 repeated On which hour(s) of the day does the event occur byweekdays RecurrenceRule.Weekday repeated On which day(s) of the week does the event occur bymonthdays int32 repeated On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1. <p>For example, -10 represents the tenth to the last day of the month. The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY. | | bymonths | uint32 | repeated | On which month(s) of the year does the event occur |</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrenceruleendcriteria","title":"RecurrenceRule.EndCriteria","text":"<p>Controls when a recurring dispatch should end</p> Field Type Label Description count uint32 The number of times this dispatch should recur. If this field is set, the dispatch will recur the given number of times. Valid values are 1 to 4096. until google.protobuf.Timestamp The end time of this dispatch in UTC. If this field is set, the last recurrence event will start before this timestamp. Note that the duration of the event is not considered in this value, so the dispatch may end after the timestamp. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#sortoptions","title":"SortOptions","text":"<p>Message defining parameters for sorting list requests.</p> <p>Example Usage: To retrieve dispatches sorted by creation time in descending order: sort_options: { field: CREATE_TIME, order: DESCENDING }</p> Field Type Label Description sort_field SortField Optional field by which to sort the results. sort_order SortOrder Optional Order in which to sort the results. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#streammicrogriddispatchesrequest","title":"StreamMicrogridDispatchesRequest","text":"<p>Subscribe to a stream of microgrid dispatch requests. This method provides real-time updates on newly or updated dispatch requests for edge-based realtime decision making.</p> Field Type Label Description microgrid_id uint64 ID of the microgrid to subscribe to <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#streammicrogriddispatchesresponse","title":"StreamMicrogridDispatchesResponse","text":"<p>Response to a subscription request for a stream of microgrid dispatches. Real-time information on dispatches affecting a certain microgrid are pushed through this response.</p> Field Type Label Description dispatch Dispatch Dispatch record returned. event StreamMicrogridDispatchesResponse.Event Which event this response was triggered by <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#targetcomponents","title":"TargetComponents","text":"<p>Parameter for controlling which components a dispatch applies to either a set of component IDs, or a set of component categories. Examples: - To dispatch to a set of component IDs:   components { component_ids { ids: [1, 2, 3] } } - To dispatch to a set of component categories:   components { component_categories { categories: [COMPONENT_CATEGORY_BATTERY, COMPONENT_CRYPTO_MINER] } }</p> Field Type Label Description component_ids TargetComponents.IdSet Set of component IDs component_categories TargetComponents.CategorySet Component categories <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#targetcomponentscategoryset","title":"TargetComponents.CategorySet","text":"<p>Wrapper for controlling dispatches with a set of component categories Required as we can't use <code>repeated</code> directly in a <code>oneof</code></p> Field Type Label Description categories frequenz.api.common.v1.microgrid.components.ComponentCategory repeated Set of component categories <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#targetcomponentsidset","title":"TargetComponents.IdSet","text":"<p>Wrapper for controlling dispatches with a set of component IDs Required as we can't use <code>repeated</code> directly in a <code>oneof</code></p> Field Type Label Description ids uint64 repeated Set of component IDs <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#timeintervalfilter","title":"TimeIntervalFilter","text":"<p>Filter parameter for specifying multiple time intervals</p> Field Type Label Description from google.protobuf.Timestamp Filter by time &gt;= this UTC timestamp. to google.protobuf.Timestamp Filter by time &lt;= this UTC timestamp. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#updatemicrogriddispatchrequest","title":"UpdateMicrogridDispatchRequest","text":"<p>Message to update the dispatch with the given ID, with the given attributes</p> Field Type Label Description microgrid_id uint64 ID of the microgrid dispatch_id uint64 The dispatch identifier update_mask google.protobuf.FieldMask Field mask specifying which fields should be updated update UpdateMicrogridDispatchRequest.DispatchUpdate The updated dispatch attributes <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#updatemicrogriddispatchrequestdispatchupdate","title":"UpdateMicrogridDispatchRequest.DispatchUpdate","text":"<p>Message containing the updated dispatch attributes</p> Field Type Label Description start_time google.protobuf.Timestamp The start time in UTC. When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. duration uint32 optional Duration in seconds target TargetComponents The target components is_active bool optional The \"active\" status payload google.protobuf.Struct The dispatch payload recurrence UpdateMicrogridDispatchRequest.DispatchUpdate.RecurrenceRuleUpdate The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#updatemicrogriddispatchrequestdispatchupdaterecurrenceruleupdate","title":"UpdateMicrogridDispatchRequest.DispatchUpdate.RecurrenceRuleUpdate","text":"<p>Message containing the updated recurrence rule attributes</p> Field Type Label Description freq RecurrenceRule.Frequency optional The frequency specifier of this recurring dispatch interval uint32 optional How often this dispatch should recur, based on the frequency end_criteria RecurrenceRule.EndCriteria When this dispatch should end. byminutes uint32 repeated On which minute(s) of the hour does the event occur byhours uint32 repeated On which hour(s) of the day does the event occur byweekdays RecurrenceRule.Weekday repeated On which day(s) of the week does the event occur bymonthdays int32 repeated On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1. <p>For example, -10 represents the tenth to the last day of the month. The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY. | | bymonths | uint32 | repeated | On which month(s) of the year does the event occur |</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#updatemicrogriddispatchresponse","title":"UpdateMicrogridDispatchResponse","text":"<p>Response message for updating a dispatch</p> Field Type Label Description dispatch Dispatch The updated dispatch <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrencerulefrequency","title":"RecurrenceRule.Frequency","text":"<p>Enum representing the frequency of the recurrence</p> Name Number Description FREQUENCY_UNSPECIFIED 0 FREQUENCY_MINUTELY 1 FREQUENCY_HOURLY 2 FREQUENCY_DAILY 3 FREQUENCY_WEEKLY 4 FREQUENCY_MONTHLY 5 FREQUENCY_YEARLY 6 <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#recurrenceruleweekday","title":"RecurrenceRule.Weekday","text":"<p>Enum representing the day of the week</p> Name Number Description WEEKDAY_UNSPECIFIED 0 WEEKDAY_MONDAY 1 WEEKDAY_TUESDAY 2 WEEKDAY_WEDNESDAY 3 WEEKDAY_THURSDAY 4 WEEKDAY_FRIDAY 5 WEEKDAY_SATURDAY 6 WEEKDAY_SUNDAY 7 <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#sortfield","title":"SortField","text":"<p>Enum for the fields to by sorted by.</p> Name Number Description SORT_FIELD_UNSPECIFIED 0 UNSPECIFIED: Default, unspecified sort field. SORT_FIELD_START_TIME 1 START_TIME: Sort by start time of the dispatch. SORT_FIELD_CREATE_TIME 2 CREATE_TIME: Sort by creation time of the dispatch. SORT_FIELD_LAST_UPDATE_TIME 3 UPDATE_TIME: Sort by last update time of the dispatch. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#sortorder","title":"SortOrder","text":"<p>Enum for sort order.</p> Name Number Description SORT_ORDER_UNSPECIFIED 0 UNSPECIFIED: Default, unspecified sort order. SORT_ORDER_ASCENDING 1 ASCENDING: Results are returned in ascending order. SORT_ORDER_DESCENDING 2 DESCENDING: Results are returned in descending order. <p></p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#streammicrogriddispatchesresponseevent","title":"StreamMicrogridDispatchesResponse.Event","text":"Name Number Description EVENT_UNSPECIFIED 0 Default, unspecified event EVENT_CREATED 1 A new dispatch has been created EVENT_UPDATED 2 An existing dispatch has been updated EVENT_DELETED 3 An existing dispatch has been deleted"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#microgriddispatchservice","title":"MicrogridDispatchService","text":"<p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to    support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p>"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#security","title":"Security","text":"<p>ALL requests to this service must be signed. The key and signature should be added to the request metadata (HTTP headers). The signature should be computed using the HMAC-SHA256 algorithm and the user's secret key.</p> <p>ALL requests to this service must be made over HTTPS.</p> Method Name Request Type Response Type Description ListMicrogridDispatches ListMicrogridDispatchesRequest ListMicrogridDispatchesResponse Returns a list of all dispatches StreamMicrogridDispatches StreamMicrogridDispatchesRequest StreamMicrogridDispatchesResponse stream Streaming RPC for receiving dispatch updates for a given microgrid CreateMicrogridDispatch CreateMicrogridDispatchRequest CreateMicrogridDispatchResponse Create a new dispatch UpdateMicrogridDispatch UpdateMicrogridDispatchRequest UpdateMicrogridDispatchResponse Update a dispatch GetMicrogridDispatch GetMicrogridDispatchRequest GetMicrogridDispatchResponse Get a single dispatch DeleteMicrogridDispatch DeleteMicrogridDispatchRequest DeleteMicrogridDispatchResponse Delete a given dispatch"},{"location":"protobuf-reference/frequenz/api/dispatch/v1/dispatch/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch_pb2</li> <li>dispatch_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/","title":"Index","text":""},{"location":"python-reference/frequenz/api/dispatch/#frequenz.api.dispatch","title":"frequenz.api.dispatch","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/","title":"Index","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/#frequenz.api.dispatch.v1","title":"frequenz.api.dispatch.v1","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/","title":"dispatch_pb2","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2","title":"frequenz.api.dispatch.v1.dispatch_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_CREATE_TIME","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_CREATE_TIME  <code>module-attribute</code>","text":"<pre><code>SORT_FIELD_CREATE_TIME: ValueType\n</code></pre> <p>CREATE_TIME: Sort by creation time of the dispatch.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_LAST_UPDATE_TIME","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_LAST_UPDATE_TIME  <code>module-attribute</code>","text":"<pre><code>SORT_FIELD_LAST_UPDATE_TIME: ValueType\n</code></pre> <p>UPDATE_TIME: Sort by last update time of the dispatch.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_START_TIME","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_START_TIME  <code>module-attribute</code>","text":"<pre><code>SORT_FIELD_START_TIME: ValueType\n</code></pre> <p>START_TIME: Sort by start time of the dispatch.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_UNSPECIFIED","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_FIELD_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>SORT_FIELD_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: Default, unspecified sort field.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_ASCENDING","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_ASCENDING  <code>module-attribute</code>","text":"<pre><code>SORT_ORDER_ASCENDING: ValueType\n</code></pre> <p>ASCENDING: Results are returned in ascending order.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_DESCENDING","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_DESCENDING  <code>module-attribute</code>","text":"<pre><code>SORT_ORDER_DESCENDING: ValueType\n</code></pre> <p>DESCENDING: Results are returned in descending order.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_UNSPECIFIED","title":"frequenz.api.dispatch.v1.dispatch_pb2.SORT_ORDER_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>SORT_ORDER_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: Default, unspecified sort order.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to create a new dispatch with the given attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchRequest.dispatch_data","title":"dispatch_data  <code>property</code>","text":"<pre><code>dispatch_data: global___DispatchData\n</code></pre> <p>Content of the dispatch to be created</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchResponse","text":"<p>               Bases: <code>Message</code></p> <p>Response message for creating a new dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.CreateMicrogridDispatchResponse.dispatch","title":"dispatch  <code>property</code>","text":"<pre><code>dispatch: global___Dispatch\n</code></pre> <p>The created dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to delete a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchRequest.dispatch_id","title":"dispatch_id  <code>instance-attribute</code>","text":"<pre><code>dispatch_id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID that the dispatch belongs to</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchResponse","text":"<p>               Bases: <code>Message</code></p> <p>Response message for deleting a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchResponse.dispatch_id","title":"dispatch_id  <code>instance-attribute</code>","text":"<pre><code>dispatch_id: int\n</code></pre> <p>The dispatch ID that was deleted</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DeleteMicrogridDispatchResponse.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID that the dispatch belonged to</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch","title":"frequenz.api.dispatch.v1.dispatch_pb2.Dispatch","text":"<p>               Bases: <code>Message</code></p> <p>Represents a dispatch, including its metadata</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.data","title":"data  <code>property</code>","text":"<pre><code>data: global___DispatchData\n</code></pre> <p>The dispatch data</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.Dispatch.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: global___DispatchMetadata\n</code></pre> <p>Dispatch Metadata (id, create time, etc)</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchData","text":"<p>               Bases: <code>Message</code></p> <p>Represents a dispatches data, including its type, start time, duration, and target components.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: int\n</code></pre> <p>Duration in seconds The duration of the dispatch in seconds. If the duration is not set, the dispatch will be considered to have an infinite duration. A duration of 0 seconds is also valid, indicating a dispatch that immediately starts and ends, e.g. switching a component on and off.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.is_active","title":"is_active  <code>instance-attribute</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.is_dry_run","title":"is_dry_run  <code>instance-attribute</code>","text":"<pre><code>is_dry_run: bool\n</code></pre> <p>The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: Struct\n</code></pre> <p>The dispatch payload.</p> <p>Note!!!     The payload field allows for flexible JSON data to be associated with this dispatch.     The payload must adhere to the following constraints:      - Maximum JSON nesting depth: 5 levels.      - The data should not contain executable code or scripts.      - Ensure all data is properly sanitized and encoded.      - The total size of the payload should not exceed 50 KB.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.recurrence","title":"recurrence  <code>property</code>","text":"<pre><code>recurrence: global___RecurrenceRule\n</code></pre> <p>The recurrence rule</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.start_time","title":"start_time  <code>property</code>","text":"<pre><code>start_time: Timestamp\n</code></pre> <p>The dispatch start time in UTC. For reoccuring dispatches this is when the first time execution occurs. When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.target","title":"target  <code>property</code>","text":"<pre><code>target: global___TargetComponents\n</code></pre> <p>The components this dispatch should apply to.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchData.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter","text":"<p>               Bases: <code>Message</code></p> <p>Parameters for filtering the dispatch list</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.end_time_interval","title":"end_time_interval  <code>property</code>","text":"<pre><code>end_time_interval: global___TimeIntervalFilter\n</code></pre> <p>Optional filter by end time Filter dispatches based on their explicit end time.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: RecurrenceFilter\n</code></pre> <p>Filter by recurrence details Examples: - To retrieve only recurring dispatches with a specific frequency:   filter { recurrence { filter { freq: FREQUENCY_DAILY } } } - To retrieve recurring dispatches with a specific frequency and interval:   filter { recurrence { filter { freq: FREQUENCY_HOURLY, interval: 2 } } } - To retrieve recurring dispatches that end after a specific criteria:   filter { recurrence { filter { end_criteria: { count: 10 } } } } - To retrieve recurring dispatches at specific minutes of the hour:   filter { recurrence { filter { byminutes: [0, 15, 30, 45] } } } - To retrieve recurring dispatches at specific hours of the day:   filter { recurrence { filter { byhours: [8, 12, 16] } } } - To retrieve recurring dispatches on specific days of the week:   filter { recurrence { filter { byweekdays: [WEEKDAY_MONDAY, WEEKDAY_WEDNESDAY] } } } - To retrieve recurring dispatches on specific days of the month:   filter { recurrence { filter { bymonthdays: [1, 15, 30, -1] } } } - To retrieve recurring dispatches in specific months of the year:   filter { recurrence { filter { bymonths: [1, 6, 12] } } }</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.is_active","title":"is_active  <code>instance-attribute</code>","text":"<pre><code>is_active: bool\n</code></pre> <p>Optional filter by active status. If this field is not set, dispatches of any active status will be included.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.is_dry_run","title":"is_dry_run  <code>instance-attribute</code>","text":"<pre><code>is_dry_run: bool\n</code></pre> <p>Optional filter by dry run status. If this field is not set, dispatches of any dry run status will be included.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.is_recurring","title":"is_recurring  <code>instance-attribute</code>","text":"<pre><code>is_recurring: bool\n</code></pre> <p>Filter by recurring status True: Only recurring dispatches will be returned. False: Only non-recurring dispatches will be returned. Examples: - To retrieve only recurring dispatches:   filter { recurrence { is_recurring: true } } - To retrieve only non-recurring dispatches:   filter { recurrence { is_recurring: false } } - To retrieve all dispatches:   filter { recurrence {} } For advanced recurrence filtering, use the <code>filter</code> field.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.start_time_interval","title":"start_time_interval  <code>property</code>","text":"<pre><code>start_time_interval: global___TimeIntervalFilter\n</code></pre> <p>Optional filter by start time. If no interval is provided, all dispatches will be returned.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.targets","title":"targets  <code>property</code>","text":"<pre><code>targets: RepeatedCompositeFieldContainer[\n    global___TargetComponents\n]\n</code></pre> <p>Optional filter by component ID or category.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.update_time_interval","title":"update_time_interval  <code>property</code>","text":"<pre><code>update_time_interval: global___TimeIntervalFilter\n</code></pre> <p>Optional filter by update time</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchFilter.RecurrenceFilter","title":"RecurrenceFilter","text":"<p>               Bases: <code>Message</code></p> <p>Recurrence filters</p> <p>The fields are left commented out for now as the exact definition and requirements for recurrence filtering are still being finalized. The frequency specifier of this recurring dispatch optional RecurrenceRule.Frequency freq = 1;</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata","title":"frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata","text":"<p>               Bases: <code>Message</code></p> <p>Represents the metadata of a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata.create_time","title":"create_time  <code>property</code>","text":"<pre><code>create_time: Timestamp\n</code></pre> <p>UTC Timestamp when the order was created.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata.dispatch_id","title":"dispatch_id  <code>instance-attribute</code>","text":"<pre><code>dispatch_id: int\n</code></pre> <p>Unique identifier of the microgrid dispatch.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: Timestamp\n</code></pre> <p>UTC Timestamp when the dispatch will stop working. Will be calculated internally based on the given: start_time, duration and RecurenceRule None if dispatch duration time is infinite and this value can't be calculated.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.DispatchMetadata.modification_time","title":"modification_time  <code>property</code>","text":"<pre><code>modification_time: Timestamp\n</code></pre> <p>UTC Timestamp of the last update to the order.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to get a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchRequest.dispatch_id","title":"dispatch_id  <code>instance-attribute</code>","text":"<pre><code>dispatch_id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID that the dispatch belongs to</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchResponse","text":"<p>               Bases: <code>Message</code></p> <p>Response message for getting a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchResponse.dispatch","title":"dispatch  <code>property</code>","text":"<pre><code>dispatch: global___Dispatch\n</code></pre> <p>The dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.GetMicrogridDispatchResponse.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID that the dispatch belongs to</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message for listing dispatches for a given microgrid.</p> <p>Allows retrieval of dispatches for a specified microgrid with optional filtering and sorting. Sorting can be specified by setting 'sort_field' and 'sort_order'. If no sorting is specified, the results will be returned by their create time in a descending order.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___DispatchFilter\n</code></pre> <p>Optional filters to apply</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The microgrid ID</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest.pagination_params","title":"pagination_params  <code>property</code>","text":"<pre><code>pagination_params: PaginationParams\n</code></pre> <p>Pagination Parameters page_size: Amount of items to return per page. Should only be provided in the first request. page_token: Cursor to specify which page to return. Should not be set in the first request.             Should be populated in subsequent requests by the <code>next_page_token</code> found in             the <code>pagination_info</code> in the response.             The tokens stays valid indefinitely.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesRequest.sort_options","title":"sort_options  <code>property</code>","text":"<pre><code>sort_options: global___SortOptions\n</code></pre> <p>Sorting options for the result</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesResponse","text":"<p>               Bases: <code>Message</code></p> <p>A list of dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesResponse.dispatches","title":"dispatches  <code>property</code>","text":"<pre><code>dispatches: RepeatedCompositeFieldContainer[\n    global___Dispatch\n]\n</code></pre> <p>The dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.ListMicrogridDispatchesResponse.pagination_info","title":"pagination_info  <code>property</code>","text":"<pre><code>pagination_info: PaginationInfo\n</code></pre> <p>Pagination Info total_items: Total amount of entries found by the list request. next_page_token: Token that can be used to request the next page.                  Will be unset if no further pages exist.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule","title":"frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule","text":"<p>               Bases: <code>Message</code></p> <p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC5545.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--examples","title":"Examples","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--every-6-months","title":"Every 6 months","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--weekends-only","title":"Weekends only","text":"<pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--at-midnight","title":"At midnight","text":"<p>Every day at midnight.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule--nightly","title":"Nightly","text":"<p>Assuming \"night\" means from 8 PM to 6 AM.</p> <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byhours","title":"byhours  <code>property</code>","text":"<pre><code>byhours: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which hour(s) of the day does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byminutes","title":"byminutes  <code>property</code>","text":"<pre><code>byminutes: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which minute(s) of the hour does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonthdays","title":"bymonthdays  <code>property</code>","text":"<pre><code>bymonthdays: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1.</p> <p>For example, -10 represents the tenth to the last day of the month. The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonths","title":"bymonths  <code>property</code>","text":"<pre><code>bymonths: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which month(s) of the year does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.byweekdays","title":"byweekdays  <code>property</code>","text":"<pre><code>byweekdays: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>On which day(s) of the week does the event occur</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.end_criteria","title":"end_criteria  <code>property</code>","text":"<pre><code>end_criteria: EndCriteria\n</code></pre> <p>When this dispatch should end. A dispatch can either recur a fixed number of times, or until a given timestamp. If this field is not set, the dispatch will recur indefinitely.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.freq","title":"freq  <code>instance-attribute</code>","text":"<pre><code>freq: ValueType\n</code></pre> <p>The frequency specifier of this recurring dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.interval","title":"interval  <code>instance-attribute</code>","text":"<pre><code>interval: int\n</code></pre> <p>How often this dispatch should recur, based on the frequency Example: - Every 2 hours:   freq = FREQUENCY_HOURLY   interval = 2 Valid values typically range between 1 and 10_000, depending on the implementation.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.EndCriteria","title":"EndCriteria","text":"<p>               Bases: <code>Message</code></p> <p>Controls when a recurring dispatch should end</p> Attributes\u00a4 count <code>instance-attribute</code> \u00a4 <pre><code>count: int\n</code></pre> <p>The number of times this dispatch should recur. If this field is set, the dispatch will recur the given number of times. Valid values are 1 to 4096.</p> until <code>property</code> \u00a4 <pre><code>until: Timestamp\n</code></pre> <p>The end time of this dispatch in UTC. If this field is set, the last recurrence event will start before this timestamp. Note that the duration of the event is not considered in this value, so the dispatch may end after the timestamp.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.Frequency","title":"Frequency","text":"<p>               Bases: <code>_Frequency</code></p> <p>Enum representing the frequency of the recurrence</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.RecurrenceRule.Weekday","title":"Weekday","text":"<p>               Bases: <code>_Weekday</code></p> <p>Enum representing the day of the week</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortField","title":"frequenz.api.dispatch.v1.dispatch_pb2.SortField","text":"<p>               Bases: <code>_SortField</code></p> <p>Enum for the fields to by sorted by.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2.py</code> <pre><code>_globals['_STREAMMICROGRIDDISPATCHESRESPONSE_EVENT']._serialized_end=692\n_globals['_DISPATCHDATA']._serialized_start=695\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortOptions","title":"frequenz.api.dispatch.v1.dispatch_pb2.SortOptions","text":"<p>               Bases: <code>Message</code></p> <p>Message defining parameters for sorting list requests.</p> <p>Example Usage: To retrieve dispatches sorted by creation time in descending order: sort_options: { field: CREATE_TIME, order: DESCENDING }</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortOptions-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortOptions.sort_field","title":"sort_field  <code>instance-attribute</code>","text":"<pre><code>sort_field: ValueType\n</code></pre> <p>Optional field by which to sort the results.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortOptions.sort_order","title":"sort_order  <code>instance-attribute</code>","text":"<pre><code>sort_order: ValueType\n</code></pre> <p>Optional Order in which to sort the results.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.SortOrder","title":"frequenz.api.dispatch.v1.dispatch_pb2.SortOrder","text":"<p>               Bases: <code>_SortOrder</code></p> <p>Enum for sort order.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2.py</code> <pre><code>_globals['_RECURRENCERULE_FREQUENCY']._serialized_end=3049\n_globals['_SORTOPTIONS']._serialized_start=3051\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesRequest","text":"<p>               Bases: <code>Message</code></p> <p>Subscribe to a stream of microgrid dispatch requests. This method provides real-time updates on newly or updated dispatch requests for edge-based realtime decision making.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2.py</code> <pre><code>_globals['_UPDATEMICROGRIDDISPATCHREQUEST']._serialized_start=3813\n_globals['_UPDATEMICROGRIDDISPATCHREQUEST']._serialized_end=4745\n_globals['_UPDATEMICROGRIDDISPATCHREQUEST_DISPATCHUPDATE']._serialized_start=4029\n_globals['_UPDATEMICROGRIDDISPATCHREQUEST_DISPATCHUPDATE']._serialized_end=4745\n_globals['_UPDATEMICROGRIDDISPATCHREQUEST_DISPATCHUPDATE_RECURRENCERULEUPDATE']._serialized_start=4359\n_globals['_UPDATEMICROGRIDDISPATCHREQUEST_DISPATCHUPDATE_RECURRENCERULEUPDATE']._serialized_end=4718\n_globals['_UPDATEMICROGRIDDISPATCHRESPONSE']._serialized_start=4747\n_globals['_UPDATEMICROGRIDDISPATCHRESPONSE']._serialized_end=4834\n_globals['_GETMICROGRIDDISPATCHREQUEST']._serialized_start=4836\n_globals['_GETMICROGRIDDISPATCHREQUEST']._serialized_end=4908\n_globals['_GETMICROGRIDDISPATCHRESPONSE']._serialized_start=4910\n_globals['_GETMICROGRIDDISPATCHRESPONSE']._serialized_end=5016\n_globals['_DELETEMICROGRIDDISPATCHREQUEST']._serialized_start=5018\n_globals['_DELETEMICROGRIDDISPATCHREQUEST']._serialized_end=5093\n_globals['_DELETEMICROGRIDDISPATCHRESPONSE']._serialized_start=5095\n_globals['_DELETEMICROGRIDDISPATCHRESPONSE']._serialized_end=5171\n_globals['_MICROGRIDDISPATCHSERVICE']._serialized_start=5397\n_globals['_MICROGRIDDISPATCHSERVICE']._serialized_end=6292\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>ID of the microgrid to subscribe to</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse","text":"<p>               Bases: <code>Message</code></p> <p>Response to a subscription request for a stream of microgrid dispatches. Real-time information on dispatches affecting a certain microgrid are pushed through this response.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.EVENT_CREATED","title":"EVENT_CREATED  <code>instance-attribute</code>","text":"<pre><code>EVENT_CREATED: ValueType\n</code></pre> <p>A new dispatch has been created</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.EVENT_DELETED","title":"EVENT_DELETED  <code>instance-attribute</code>","text":"<pre><code>EVENT_DELETED: ValueType\n</code></pre> <p>An existing dispatch has been deleted</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.EVENT_UNSPECIFIED","title":"EVENT_UNSPECIFIED  <code>instance-attribute</code>","text":"<pre><code>EVENT_UNSPECIFIED: ValueType\n</code></pre> <p>Default, unspecified event</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.EVENT_UPDATED","title":"EVENT_UPDATED  <code>instance-attribute</code>","text":"<pre><code>EVENT_UPDATED: ValueType\n</code></pre> <p>An existing dispatch has been updated</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.dispatch","title":"dispatch  <code>property</code>","text":"<pre><code>dispatch: global___Dispatch\n</code></pre> <p>Dispatch record returned.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.StreamMicrogridDispatchesResponse.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: ValueType\n</code></pre> <p>Which event this response was triggered by</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents","title":"frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents","text":"<p>               Bases: <code>Message</code></p> <p>Parameter for controlling which components a dispatch applies to either a set of component IDs, or a set of component categories. Examples: - To dispatch to a set of component IDs:   components { component_ids { ids: [1, 2, 3] } } - To dispatch to a set of component categories:   components { component_categories { categories: [COMPONENT_CATEGORY_BATTERY, COMPONENT_CRYPTO_MINER] } }</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents.component_categories","title":"component_categories  <code>property</code>","text":"<pre><code>component_categories: CategorySet\n</code></pre> <p>Component categories</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: IdSet\n</code></pre> <p>Set of component IDs</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents.CategorySet","title":"CategorySet","text":"<p>               Bases: <code>Message</code></p> <p>Wrapper for controlling dispatches with a set of component categories Required as we can't use <code>repeated</code> directly in a <code>oneof</code></p> Attributes\u00a4 categories <code>property</code> \u00a4 <pre><code>categories: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>Set of component categories</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TargetComponents.IdSet","title":"IdSet","text":"<p>               Bases: <code>Message</code></p> <p>Wrapper for controlling dispatches with a set of component IDs Required as we can't use <code>repeated</code> directly in a <code>oneof</code></p> Attributes\u00a4 ids <code>property</code> \u00a4 <pre><code>ids: RepeatedScalarFieldContainer[int]\n</code></pre> <p>Set of component IDs</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter","title":"frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter","text":"<p>               Bases: <code>Message</code></p> <p>Filter parameter for specifying multiple time intervals</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.TimeIntervalFilter.to","title":"to  <code>property</code>","text":"<pre><code>to: Timestamp\n</code></pre> <p>Filter by time &lt;= this UTC timestamp.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest","title":"frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest","text":"<p>               Bases: <code>Message</code></p> <p>Message to update the dispatch with the given ID, with the given attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest.dispatch_id","title":"dispatch_id  <code>instance-attribute</code>","text":"<pre><code>dispatch_id: int\n</code></pre> <p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>ID of the microgrid</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest.update","title":"update  <code>property</code>","text":"<pre><code>update: DispatchUpdate\n</code></pre> <p>The updated dispatch attributes</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest.update_mask","title":"update_mask  <code>property</code>","text":"<pre><code>update_mask: FieldMask\n</code></pre> <p>Field mask specifying which fields should be updated</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchRequest.DispatchUpdate","title":"DispatchUpdate","text":"<p>               Bases: <code>Message</code></p> <p>Message containing the updated dispatch attributes</p> Attributes\u00a4 duration <code>instance-attribute</code> \u00a4 <pre><code>duration: int\n</code></pre> <p>Duration in seconds</p> is_active <code>instance-attribute</code> \u00a4 <pre><code>is_active: bool\n</code></pre> <p>The \"active\" status</p> payload <code>property</code> \u00a4 <pre><code>payload: Struct\n</code></pre> <p>The dispatch payload</p> recurrence <code>property</code> \u00a4 <pre><code>recurrence: RecurrenceRuleUpdate\n</code></pre> <p>The recurrence rule</p> start_time <code>property</code> \u00a4 <pre><code>start_time: Timestamp\n</code></pre> <p>The start time in UTC. When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p> target <code>property</code> \u00a4 <pre><code>target: global___TargetComponents\n</code></pre> <p>The target components</p> Classes\u00a4 RecurrenceRuleUpdate \u00a4 <p>               Bases: <code>Message</code></p> <p>Message containing the updated recurrence rule attributes</p> Attributes\u00a4 byhours <code>property</code> \u00a4 <pre><code>byhours: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which hour(s) of the day does the event occur</p> byminutes <code>property</code> \u00a4 <pre><code>byminutes: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which minute(s) of the hour does the event occur</p> bymonthdays <code>property</code> \u00a4 <pre><code>bymonthdays: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1.</p> <p>For example, -10 represents the tenth to the last day of the month. The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY.</p> bymonths <code>property</code> \u00a4 <pre><code>bymonths: RepeatedScalarFieldContainer[int]\n</code></pre> <p>On which month(s) of the year does the event occur</p> byweekdays <code>property</code> \u00a4 <pre><code>byweekdays: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>On which day(s) of the week does the event occur</p> end_criteria <code>property</code> \u00a4 <pre><code>end_criteria: EndCriteria\n</code></pre> <p>When this dispatch should end.</p> freq <code>instance-attribute</code> \u00a4 <pre><code>freq: ValueType\n</code></pre> <p>The frequency specifier of this recurring dispatch</p> interval <code>instance-attribute</code> \u00a4 <pre><code>interval: int\n</code></pre> <p>How often this dispatch should recur, based on the frequency</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchResponse","title":"frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchResponse","text":"<p>               Bases: <code>Message</code></p> <p>Response message for updating a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2/#frequenz.api.dispatch.v1.dispatch_pb2.UpdateMicrogridDispatchResponse.dispatch","title":"dispatch  <code>property</code>","text":"<pre><code>dispatch: global___Dispatch\n</code></pre> <p>The updated dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/","title":"dispatch_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService--security","title":"Security","text":"<p>ALL requests to this service must be signed. The key and signature should be added to the request metadata (HTTP headers). The signature should be computed using the HMAC-SHA256 algorithm and the user's secret key.</p> <p>ALL requests to this service must be made over HTTPS.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchService(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n\n    #### Security\n\n    ALL requests to this service must be signed. The key and signature\n    should be added to the request metadata (HTTP headers). The signature\n    should be computed using the HMAC-SHA256 algorithm and the user's secret key.\n\n    ALL requests to this service must be made over HTTPS.\n    \"\"\"\n\n    @staticmethod\n    def ListMicrogridDispatches(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def StreamMicrogridDispatches(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/StreamMicrogridDispatches',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def CreateMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def UpdateMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def GetMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def DeleteMicrogridDispatch(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchRequest.SerializeToString,\n            frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub","text":"<p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to    support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub--security","title":"Security","text":"<p>ALL requests to this service must be signed. The key and signature should be added to the request metadata (HTTP headers). The signature should be computed using the HMAC-SHA256 algorithm and the user's secret key.</p> <p>ALL requests to this service must be made over HTTPS.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceServicer(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n\n    #### Security\n\n    ALL requests to this service must be signed. The key and signature\n    should be added to the request metadata (HTTP headers). The signature\n    should be computed using the HMAC-SHA256 algorithm and the user's secret key.\n\n    ALL requests to this service must be made over HTTPS.\n    \"\"\"\n\n    def ListMicrogridDispatches(self, request, context):\n        \"\"\"Returns a list of all dispatches\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StreamMicrogridDispatches(self, request, context):\n        \"\"\"Streaming RPC for receiving dispatch updates for a given microgrid\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CreateMicrogridDispatch(self, request, context):\n        \"\"\"Create a new dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def UpdateMicrogridDispatch(self, request, context):\n        \"\"\"Update a dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def GetMicrogridDispatch(self, request, context):\n        \"\"\"Get a single dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.CreateMicrogridDispatch","title":"CreateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>CreateMicrogridDispatch: UnaryUnaryMultiCallable[\n    CreateMicrogridDispatchRequest,\n    CreateMicrogridDispatchResponse,\n]\n</code></pre> <p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>DeleteMicrogridDispatch: UnaryUnaryMultiCallable[\n    DeleteMicrogridDispatchRequest,\n    DeleteMicrogridDispatchResponse,\n]\n</code></pre> <p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.GetMicrogridDispatch","title":"GetMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>GetMicrogridDispatch: UnaryUnaryMultiCallable[\n    GetMicrogridDispatchRequest,\n    GetMicrogridDispatchResponse,\n]\n</code></pre> <p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.ListMicrogridDispatches","title":"ListMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>ListMicrogridDispatches: UnaryUnaryMultiCallable[\n    ListMicrogridDispatchesRequest,\n    ListMicrogridDispatchesResponse,\n]\n</code></pre> <p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.StreamMicrogridDispatches","title":"StreamMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>StreamMicrogridDispatches: UnaryStreamMultiCallable[\n    StreamMicrogridDispatchesRequest,\n    StreamMicrogridDispatchesResponse,\n]\n</code></pre> <p>Streaming RPC for receiving dispatch updates for a given microgrid</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>UpdateMicrogridDispatch: UnaryUnaryMultiCallable[\n    UpdateMicrogridDispatchRequest,\n    UpdateMicrogridDispatchResponse,\n]\n</code></pre> <p>Update a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer--security","title":"Security","text":"<p>ALL requests to this service must be signed. The key and signature should be added to the request metadata (HTTP headers). The signature should be computed using the HMAC-SHA256 algorithm and the user's secret key.</p> <p>ALL requests to this service must be made over HTTPS.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceServicer(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n\n    #### Security\n\n    ALL requests to this service must be signed. The key and signature\n    should be added to the request metadata (HTTP headers). The signature\n    should be computed using the HMAC-SHA256 algorithm and the user's secret key.\n\n    ALL requests to this service must be made over HTTPS.\n    \"\"\"\n\n    def ListMicrogridDispatches(self, request, context):\n        \"\"\"Returns a list of all dispatches\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StreamMicrogridDispatches(self, request, context):\n        \"\"\"Streaming RPC for receiving dispatch updates for a given microgrid\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CreateMicrogridDispatch(self, request, context):\n        \"\"\"Create a new dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def UpdateMicrogridDispatch(self, request, context):\n        \"\"\"Update a dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def GetMicrogridDispatch(self, request, context):\n        \"\"\"Get a single dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def DeleteMicrogridDispatch(self, request, context):\n        \"\"\"Delete a given dispatch\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.CreateMicrogridDispatch","title":"CreateMicrogridDispatch","text":"<pre><code>CreateMicrogridDispatch(\n    request: CreateMicrogridDispatchRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    CreateMicrogridDispatchResponse,\n    Awaitable[CreateMicrogridDispatchResponse],\n]\n</code></pre> <p>Create a new dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def CreateMicrogridDispatch(self, request, context):\n    \"\"\"Create a new dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch","text":"<pre><code>DeleteMicrogridDispatch(\n    request: DeleteMicrogridDispatchRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    DeleteMicrogridDispatchResponse,\n    Awaitable[DeleteMicrogridDispatchResponse],\n]\n</code></pre> <p>Delete a given dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def DeleteMicrogridDispatch(self, request, context):\n    \"\"\"Delete a given dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.GetMicrogridDispatch","title":"GetMicrogridDispatch","text":"<pre><code>GetMicrogridDispatch(\n    request: GetMicrogridDispatchRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    GetMicrogridDispatchResponse,\n    Awaitable[GetMicrogridDispatchResponse],\n]\n</code></pre> <p>Get a single dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def GetMicrogridDispatch(self, request, context):\n    \"\"\"Get a single dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.ListMicrogridDispatches","title":"ListMicrogridDispatches","text":"<pre><code>ListMicrogridDispatches(\n    request: ListMicrogridDispatchesRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    ListMicrogridDispatchesResponse,\n    Awaitable[ListMicrogridDispatchesResponse],\n]\n</code></pre> <p>Returns a list of all dispatches</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def ListMicrogridDispatches(self, request, context):\n    \"\"\"Returns a list of all dispatches\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.StreamMicrogridDispatches","title":"StreamMicrogridDispatches","text":"<pre><code>StreamMicrogridDispatches(\n    request: StreamMicrogridDispatchesRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    Iterator[StreamMicrogridDispatchesResponse],\n    AsyncIterator[StreamMicrogridDispatchesResponse],\n]\n</code></pre> <p>Streaming RPC for receiving dispatch updates for a given microgrid</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def StreamMicrogridDispatches(self, request, context):\n    \"\"\"Streaming RPC for receiving dispatch updates for a given microgrid\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch","text":"<pre><code>UpdateMicrogridDispatch(\n    request: UpdateMicrogridDispatchRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    UpdateMicrogridDispatchResponse,\n    Awaitable[UpdateMicrogridDispatchResponse],\n]\n</code></pre> <p>Update a dispatch</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def UpdateMicrogridDispatch(self, request, context):\n    \"\"\"Update a dispatch\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub","title":"frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub","text":"<p>               Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--overview","title":"Overview","text":"<p>The API serves to automate the process of electricity dispatches for microgrids. In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power between different components within a microgrid or between a microgrid and the main grid. This could be for the purpose of supply (sending electricity to the grid or components within the microgrid), or demand (drawing electricity from the grid or from other components like batteries and solar arrays).</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--objective","title":"Objective","text":"<p>The primary objective of this API is to streamline and automate the complex task of electricity dispatching, making it easier to manage local electricity supply and demand efficiently.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--key-features","title":"Key Features","text":"<ul> <li>Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.</li> <li>Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.</li> <li>Fine-grained control: Dispatch individual microgrid components or entire component categories.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--example-use-cases","title":"Example Use Cases","text":"<ul> <li>Charging or discharging a battery based on optimal time-of-use rates.</li> <li>Limiting the output of a Photovoltaic (PV) array during periods of low demand.</li> <li>Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to support grid operations.</li> <li>Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.</li> </ul>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems.</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub--security","title":"Security","text":"<p>ALL requests to this service must be signed. The key and signature should be added to the request metadata (HTTP headers). The signature should be computed using the HMAC-SHA256 algorithm and the user's secret key.</p> <p>ALL requests to this service must be made over HTTPS.</p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceStub(object):\n    \"\"\"Service providing operations related to dispatching microgrid components.\n\n    #### Overview\n\n    The API serves to automate the process of electricity dispatches for microgrids.\n    In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power\n    between different components within a microgrid or between a microgrid and the main grid.\n    This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),\n    or demand (drawing electricity from the grid or from other components like batteries and solar arrays).\n\n    #### Objective\n\n    The primary objective of this API is to streamline and automate the complex task of electricity dispatching,\n    making it easier to manage local electricity supply and demand efficiently.\n\n    #### Key Features\n\n    - Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.\n    - Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.\n    - Fine-grained control: Dispatch individual microgrid components or entire component categories.\n\n    #### Example Use Cases\n\n    - Charging or discharging a battery based on optimal time-of-use rates.\n    - Limiting the output of a Photovoltaic (PV) array during periods of low demand.\n    - Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to\n    support grid operations.\n    - Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.\n\n    #### Target Audience\n\n    This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid\n    electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in\n    electrical engineering and systems.\n\n    #### Security\n\n    ALL requests to this service must be signed. The key and signature\n    should be added to the request metadata (HTTP headers). The signature\n    should be computed using the HMAC-SHA256 algorithm and the user's secret key.\n\n    ALL requests to this service must be made over HTTPS.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.ListMicrogridDispatches = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesResponse.FromString,\n                _registered_method=True)\n        self.StreamMicrogridDispatches = channel.unary_stream(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/StreamMicrogridDispatches',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesResponse.FromString,\n                _registered_method=True)\n        self.CreateMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchResponse.FromString,\n                _registered_method=True)\n        self.UpdateMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchResponse.FromString,\n                _registered_method=True)\n        self.GetMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchResponse.FromString,\n                _registered_method=True)\n        self.DeleteMicrogridDispatch = channel.unary_unary(\n                '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n                request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchResponse.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.CreateMicrogridDispatch","title":"CreateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>CreateMicrogridDispatch: UnaryUnaryMultiCallable[\n    CreateMicrogridDispatchRequest,\n    CreateMicrogridDispatchResponse,\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.DeleteMicrogridDispatch","title":"DeleteMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>DeleteMicrogridDispatch: UnaryUnaryMultiCallable[\n    DeleteMicrogridDispatchRequest,\n    DeleteMicrogridDispatchResponse,\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.GetMicrogridDispatch","title":"GetMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>GetMicrogridDispatch: UnaryUnaryMultiCallable[\n    GetMicrogridDispatchRequest,\n    GetMicrogridDispatchResponse,\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.ListMicrogridDispatches","title":"ListMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>ListMicrogridDispatches: UnaryUnaryMultiCallable[\n    ListMicrogridDispatchesRequest,\n    ListMicrogridDispatchesResponse,\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.StreamMicrogridDispatches","title":"StreamMicrogridDispatches  <code>instance-attribute</code>","text":"<pre><code>StreamMicrogridDispatches: UnaryStreamMultiCallable[\n    StreamMicrogridDispatchesRequest,\n    StreamMicrogridDispatchesResponse,\n] = unary_stream(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/StreamMicrogridDispatches\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Streaming RPC for receiving dispatch updates for a given microgrid</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.UpdateMicrogridDispatch","title":"UpdateMicrogridDispatch  <code>instance-attribute</code>","text":"<pre><code>UpdateMicrogridDispatch: UnaryUnaryMultiCallable[\n    UpdateMicrogridDispatchRequest,\n    UpdateMicrogridDispatchResponse,\n] = unary_unary(\n    \"/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n    _registered_method=True,\n)\n</code></pre> <p>Update a dispatch</p>"},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/dispatch/v1/dispatch_pb2_grpc/#frequenz.api.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.__init__","title":"__init__","text":"<pre><code>__init__(channel: Union[Channel, Channel]) -&gt; None\n</code></pre> <p>Constructor.</p> PARAMETER DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>frequenz/api/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.ListMicrogridDispatches = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.ListMicrogridDispatchesResponse.FromString,\n            _registered_method=True)\n    self.StreamMicrogridDispatches = channel.unary_stream(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/StreamMicrogridDispatches',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.StreamMicrogridDispatchesResponse.FromString,\n            _registered_method=True)\n    self.CreateMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.CreateMicrogridDispatchResponse.FromString,\n            _registered_method=True)\n    self.UpdateMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.UpdateMicrogridDispatchResponse.FromString,\n            _registered_method=True)\n    self.GetMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.GetMicrogridDispatchResponse.FromString,\n            _registered_method=True)\n    self.DeleteMicrogridDispatch = channel.unary_unary(\n            '/frequenz.api.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\n            request_serializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_dispatch_dot_v1_dot_dispatch__pb2.DeleteMicrogridDispatchResponse.FromString,\n            _registered_method=True)\n</code></pre>"}]}