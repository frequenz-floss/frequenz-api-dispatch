{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Dispatch API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p> <p>Dispatches might include, for example:</p> <ul> <li>Hard shutdown of a location or an individual microgrid component</li> <li>Charging or discharging a battery</li> <li>Activation or deactivation of balancing power</li> <li>Activation or deactivation of a power plant</li> </ul> <p>Microgrid controllers are expected to regularly query this API to keep up to date with what resources the cloud wishes them to deploy.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Dispatch API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/dispatch/v1/dispatch.proto</p> <ul> <li>ComponentIDs</li> <li>ComponentSelector</li> <li>Dispatch</li> <li>DispatchCreateRequest</li> <li>DispatchDeleteRequest</li> <li>DispatchFilter</li> <li>DispatchGetRequest</li> <li>DispatchList</li> <li>DispatchListRequest</li> <li>DispatchUpdateRequest</li> <li>RecurrenceRule</li> <li> <p>TimeIntervalFilter</p> </li> <li> <p>RecurrenceRule.Frequency</p> </li> <li> <p>RecurrenceRule.Weekday</p> </li> <li> <p>MicrogridDispatchService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#frequenzdispatchv1dispatchproto","title":"frequenz/dispatch/v1/dispatch.proto","text":""},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#componentids","title":"ComponentIDs","text":"<p>Wrapper for controlling dispatches with a set of component IDs</p> Field Type Label Description component_ids uint64 repeated Set of component IDs <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#componentselector","title":"ComponentSelector","text":"<p>Parameter for controlling which components a dispatch applies to Either a set of component IDs, or all components belonging to a category</p> Field Type Label Description component_ids ComponentIDs Set of component IDs component_category frequenz.api.common.components.ComponentCategory Component category <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatch","title":"Dispatch","text":"<p>Message representing one dispatch.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> Field Type Label Description id uint64 The dispatch identifier microgrid_id uint64 The microgrid identifier type string The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field. create_time google.protobuf.Timestamp The creation time in UTC This is set when a dispatch is created via the create request message update_time google.protobuf.Timestamp The update time in UTC This is set when a dispatch is modified via the update request message start_time google.protobuf.Timestamp The start time in UTC end_time google.protobuf.Timestamp The end time in UTC selector ComponentSelector The component selector is_active bool The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion. is_dry_run bool The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes. payload google.protobuf.Struct The dispatch payload recurrence RecurrenceRule The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchcreaterequest","title":"DispatchCreateRequest","text":"<p>Message to create a new dispatch with the given attributes</p> Field Type Label Description microgrid_id uint64 The microgrid identifier type string The type of dispatch start_time google.protobuf.Timestamp The start time When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. end_time google.protobuf.Timestamp The end time selector ComponentSelector The component selector is_active bool The \"active\" status is_dry_run bool The \"dry run\" status payload google.protobuf.Struct The dispatch payload recurrence RecurrenceRule The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchdeleterequest","title":"DispatchDeleteRequest","text":"<p>Message to delete a single dispatch by its ID</p> Field Type Label Description id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchfilter","title":"DispatchFilter","text":"<p>Parameters for filtering the dispatch list</p> Field Type Label Description selectors ComponentSelector repeated Filter by component ID or category time_interval TimeIntervalFilter Filter by time interval If no interval is provided, all dispatches starting from the current timestamp will be included. is_active bool optional Filter by active status If this field is not set, dispatches of any active status will be included. is_dry_run bool optional Filter by dry run status If this field is not set, dispatches of any dry run status will be included. <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchgetrequest","title":"DispatchGetRequest","text":"<p>Message to get a single dispatch by its ID</p> Field Type Label Description id uint64 The dispatch identifier <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchlist","title":"DispatchList","text":"<p>A list of dispatches</p> Field Type Label Description dispatches Dispatch repeated The dispatches <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchlistrequest","title":"DispatchListRequest","text":"<p>Message for listing dispatches for a given microgrid, and an optional filter</p> Field Type Label Description microgrid_id uint64 The microgrid ID filter DispatchFilter Additional filter parameters <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#dispatchupdaterequest","title":"DispatchUpdateRequest","text":"<p>Message to update the dispatch with the given ID, with the given attributes</p> Field Type Label Description id uint64 The dispatch identifier start_time google.protobuf.Timestamp The start time When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed. end_time google.protobuf.Timestamp The end time selector ComponentSelector The component selector is_active bool optional The \"active\" status is_dry_run bool optional The \"dry run\" status payload google.protobuf.Struct The dispatch payload recurrence RecurrenceRule The recurrence rule <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#recurrencerule","title":"RecurrenceRule","text":"<p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC 5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC 5545.</p> <p>Examples:</p> <p>Every 6 months: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre></p> <p>Weekends only: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre></p> <p>Every day at midnight: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre></p> <p>Nightly, assuming \"night\" means from 8 PM to 6 AM: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre></p> Field Type Label Description freq RecurrenceRule.Frequency The frequency specifier of this recurring dispatch interval uint32 How often this dispatch should recur, based on the frequency Example: - Every 2 hours: freq = FREQUENCY_HOURLY interval = 2 count uint32 optional (Optional) limit the number of occurences If this field is not set, the dispatch will recur indefinitely byminutes uint32 repeated On which minute(s) of the hour does the event occur byhours uint32 repeated On which hour(s) of the day does the event occur byweekdays RecurrenceRule.Weekday repeated On which day(s) of the week does the event occur bymonthdays uint32 repeated On which day(s) of the month does the event occur bymonths uint32 repeated On which month(s) of the year does the event occur <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#timeintervalfilter","title":"TimeIntervalFilter","text":"<p>Filter parameter for specifying multiple time intervals</p> Field Type Label Description start_from google.protobuf.Timestamp Filter by start_time &gt;= this timestamp start_to google.protobuf.Timestamp Filter by start_time &lt; this timestamp end_from google.protobuf.Timestamp Filter by end_time &gt;= this timestamp end_to google.protobuf.Timestamp Filter by end_time &lt; this timestamp <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#recurrencerulefrequency","title":"RecurrenceRule.Frequency","text":"<p>Enum representing the frequency of the recurrence</p> Name Number Description FREQUENCY_UNSPECIFIED 0 FREQUENCY_MINUTELY 1 FREQUENCY_HOURLY 2 FREQUENCY_DAILY 3 FREQUENCY_WEEKLY 4 FREQUENCY_MONTHLY 5 <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#recurrenceruleweekday","title":"RecurrenceRule.Weekday","text":"<p>Enum representing the day of the week</p> Name Number Description WEEKDAY_UNSPECIFIED 0 WEEKDAY_MONDAY 1 WEEKDAY_TUESDAY 2 WEEKDAY_WEDNESDAY 3 WEEKDAY_THURSDAY 4 WEEKDAY_FRIDAY 5 WEEKDAY_SATURDAY 6 WEEKDAY_SUNDAY 7 <p></p>"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#microgriddispatchservice","title":"MicrogridDispatchService","text":"<p>Service providing operations related to dispatching microgrid components.</p> Method Name Request Type Response Type Description ListMicrogridDispatches DispatchListRequest DispatchList Returns a list of all dispatches CreateMicrogridDispatch DispatchCreateRequest .google.protobuf.Empty Create a new dispatch UpdateMicrogridDispatch DispatchUpdateRequest .google.protobuf.Empty Update a dispatch GetMicrogridDispatch DispatchGetRequest Dispatch Get a single dispatch DeleteMicrogridDispatch DispatchDeleteRequest .google.protobuf.Empty Delete a given dispatch"},{"location":"protobuf-reference/frequenz/dispatch/v1/dispatch/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>dispatch<ul> <li>v1<ul> <li>dispatch_pb2</li> <li>dispatch_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/dispatch/v1/","title":"v1","text":""},{"location":"python-reference/frequenz/dispatch/v1/#frequenz.dispatch.v1","title":"<code>frequenz.dispatch.v1</code>","text":"<p>Frequenz gRPC API to propagate dispatches to microgrids.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/","title":"dispatch_pb2","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2","title":"<code>frequenz.dispatch.v1.dispatch_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentIDs","title":"<code>frequenz.dispatch.v1.dispatch_pb2.ComponentIDs</code>","text":"<p>             Bases: <code>Message</code></p> <p>Wrapper for controlling dispatches with a set of component IDs</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentIDs-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentIDs.component_ids","title":"<code>component_ids: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Set of component IDs</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentSelector","title":"<code>frequenz.dispatch.v1.dispatch_pb2.ComponentSelector</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameter for controlling which components a dispatch applies to Either a set of component IDs, or all components belonging to a category</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentSelector-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentSelector.component_category","title":"<code>component_category: frequenz.api.common.components_pb2.ComponentCategory.ValueType</code>  <code>instance-attribute</code>","text":"<p>Component category</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.ComponentSelector.component_ids","title":"<code>component_ids: global___ComponentIDs</code>  <code>property</code>","text":"<p>Set of component IDs</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch","title":"<code>frequenz.dispatch.v1.dispatch_pb2.Dispatch</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message representing one dispatch.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2.py</code> <pre><code># @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.create_time","title":"<code>create_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The creation time in UTC This is set when a dispatch is created via the create request message</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.end_time","title":"<code>end_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The end time in UTC</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.is_active","title":"<code>is_active: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"active\" status An active dispatch is eligible for processing, either immediately or at a scheduled time in the future, including recurring dispatches. If a dispatch is set to inactive, it won't be processed even if it matches all other conditions, allowing for temporary disabling of dispatches without deletion.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.is_dry_run","title":"<code>is_dry_run: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"dry run\" status A dry run dispatch is executed for logging and monitoring purposes without affecting the microgrid components. This is useful, for example, in scenarios where a user may want to test dispatch behavior without actually affecting any component states. Notably, a dispatch can be both \"dry run\" and \"active,\" allowing for the system to generate logs and observe behavior without making actual changes.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.microgrid_id","title":"<code>microgrid_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The microgrid identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.payload","title":"<code>payload: google.protobuf.struct_pb2.Struct</code>  <code>property</code>","text":"<p>The dispatch payload</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.recurrence","title":"<code>recurrence: global___RecurrenceRule</code>  <code>property</code>","text":"<p>The recurrence rule</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.selector","title":"<code>selector: global___ComponentSelector</code>  <code>property</code>","text":"<p>The component selector</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.start_time","title":"<code>start_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The start time in UTC</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.type","title":"<code>type: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The dispatch type. Contains user-defined information about what \"type\" of dispatch this is. Downstream applications that consume the dispatch API are responsible for understanding and processing this field.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.Dispatch.update_time","title":"<code>update_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The update time in UTC This is set when a dispatch is modified via the update request message</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message to create a new dispatch with the given attributes</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.end_time","title":"<code>end_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The end time</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.is_active","title":"<code>is_active: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"active\" status</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.is_dry_run","title":"<code>is_dry_run: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"dry run\" status</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.microgrid_id","title":"<code>microgrid_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The microgrid identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.payload","title":"<code>payload: google.protobuf.struct_pb2.Struct</code>  <code>property</code>","text":"<p>The dispatch payload</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.recurrence","title":"<code>recurrence: global___RecurrenceRule</code>  <code>property</code>","text":"<p>The recurrence rule</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.selector","title":"<code>selector: global___ComponentSelector</code>  <code>property</code>","text":"<p>The component selector</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.start_time","title":"<code>start_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The start time When creating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest.type","title":"<code>type: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The type of dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message to delete a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchFilter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for filtering the dispatch list</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter.is_active","title":"<code>is_active: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>Filter by active status If this field is not set, dispatches of any active status will be included.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter.is_dry_run","title":"<code>is_dry_run: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>Filter by dry run status If this field is not set, dispatches of any dry run status will be included.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter.selectors","title":"<code>selectors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComponentSelector]</code>  <code>property</code>","text":"<p>Filter by component ID or category</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchFilter.time_interval","title":"<code>time_interval: global___TimeIntervalFilter</code>  <code>property</code>","text":"<p>Filter by time interval If no interval is provided, all dispatches starting from the current timestamp will be included.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message to get a single dispatch by its ID</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchList","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchList</code>","text":"<p>             Bases: <code>Message</code></p> <p>A list of dispatches</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchList-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchList.dispatches","title":"<code>dispatches: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dispatch]</code>  <code>property</code>","text":"<p>The dispatches</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message for listing dispatches for a given microgrid, and an optional filter</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest.filter","title":"<code>filter: global___DispatchFilter</code>  <code>property</code>","text":"<p>Additional filter parameters</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest.microgrid_id","title":"<code>microgrid_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The microgrid ID</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest","title":"<code>frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Message to update the dispatch with the given ID, with the given attributes</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.end_time","title":"<code>end_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The end time</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The dispatch identifier</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.is_active","title":"<code>is_active: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"active\" status</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.is_dry_run","title":"<code>is_dry_run: builtins.bool</code>  <code>instance-attribute</code>","text":"<p>The \"dry run\" status</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.payload","title":"<code>payload: google.protobuf.struct_pb2.Struct</code>  <code>property</code>","text":"<p>The dispatch payload</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.recurrence","title":"<code>recurrence: global___RecurrenceRule</code>  <code>property</code>","text":"<p>The recurrence rule</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.selector","title":"<code>selector: global___ComponentSelector</code>  <code>property</code>","text":"<p>The component selector</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest.start_time","title":"<code>start_time: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The start time When updating a dispatch, ensure that the starting timestamp is set to the current time or any future time. Timestamps earlier than the current time are not allowed.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule","title":"<code>frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule</code>","text":"<p>             Bases: <code>Message</code></p> <p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC to its local timezone.</p> <p>This definition tries to adhere closely to the iCalendar specification (RFC 5545), particularly for recurrence rules. For advanced use-cases or further clarifications, refer to RFC 5545.</p> <p>Examples:</p> <p>Every 6 months: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_MONTHLY;\n  uint32 interval = 6;\n}\n</code></pre></p> <p>Weekends only: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_WEEKLY;\n  repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];\n}\n</code></pre></p> <p>Every day at midnight: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [0];\n}\n</code></pre></p> <p>Nightly, assuming \"night\" means from 8 PM to 6 AM: <pre><code>message RecurrenceRule {\n  Frequency freq = FREQUENCY_DAILY;\n  repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];\n}\n</code></pre></p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.byhours","title":"<code>byhours: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>On which hour(s) of the day does the event occur</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.byminutes","title":"<code>byminutes: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>On which minute(s) of the hour does the event occur</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonthdays","title":"<code>bymonthdays: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>On which day(s) of the month does the event occur</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.bymonths","title":"<code>bymonths: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>On which month(s) of the year does the event occur</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.byweekdays","title":"<code>byweekdays: google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]</code>  <code>property</code>","text":"<p>On which day(s) of the week does the event occur</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.count","title":"<code>count: builtins.int</code>  <code>instance-attribute</code>","text":"<p>(Optional) limit the number of occurences If this field is not set, the dispatch will recur indefinitely</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.freq","title":"<code>freq: global___RecurrenceRule.Frequency.ValueType</code>  <code>instance-attribute</code>","text":"<p>The frequency specifier of this recurring dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.interval","title":"<code>interval: builtins.int</code>  <code>instance-attribute</code>","text":"<p>How often this dispatch should recur, based on the frequency Example: - Every 2 hours:   freq = FREQUENCY_HOURLY   interval = 2</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.Frequency","title":"<code>Frequency</code>","text":"<p>             Bases: <code>_Frequency</code></p> <p>Enum representing the frequency of the recurrence</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.RecurrenceRule.Weekday","title":"<code>Weekday</code>","text":"<p>             Bases: <code>_Weekday</code></p> <p>Enum representing the day of the week</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter","title":"<code>frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Filter parameter for specifying multiple time intervals</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter.end_from","title":"<code>end_from: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>Filter by end_time &gt;= this timestamp</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter.end_to","title":"<code>end_to: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>Filter by end_time &lt; this timestamp</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter.start_from","title":"<code>start_from: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>Filter by start_time &gt;= this timestamp</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2/#frequenz.dispatch.v1.dispatch_pb2.TimeIntervalFilter.start_to","title":"<code>start_to: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>Filter by start_time &lt; this timestamp</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/","title":"dispatch_pb2_grpc","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc","title":"<code>frequenz.dispatch.v1.dispatch_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService","title":"<code>frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchService</code>","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchService(object):\n\"\"\"Service providing operations related to dispatching microgrid components.\n    \"\"\"\n@staticmethod\ndef ListMicrogridDispatches(request,\ntarget,\noptions=(),\nchannel_credentials=None,\ncall_credentials=None,\ninsecure=False,\ncompression=None,\nwait_for_ready=None,\ntimeout=None,\nmetadata=None):\nreturn grpc.experimental.unary_unary(request, target, '/frequenz.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\noptions, channel_credentials,\ninsecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n@staticmethod\ndef CreateMicrogridDispatch(request,\ntarget,\noptions=(),\nchannel_credentials=None,\ncall_credentials=None,\ninsecure=False,\ncompression=None,\nwait_for_ready=None,\ntimeout=None,\nmetadata=None):\nreturn grpc.experimental.unary_unary(request, target, '/frequenz.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\ngoogle_dot_protobuf_dot_empty__pb2.Empty.FromString,\noptions, channel_credentials,\ninsecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n@staticmethod\ndef UpdateMicrogridDispatch(request,\ntarget,\noptions=(),\nchannel_credentials=None,\ncall_credentials=None,\ninsecure=False,\ncompression=None,\nwait_for_ready=None,\ntimeout=None,\nmetadata=None):\nreturn grpc.experimental.unary_unary(request, target, '/frequenz.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\ngoogle_dot_protobuf_dot_empty__pb2.Empty.FromString,\noptions, channel_credentials,\ninsecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n@staticmethod\ndef GetMicrogridDispatch(request,\ntarget,\noptions=(),\nchannel_credentials=None,\ncall_credentials=None,\ninsecure=False,\ncompression=None,\nwait_for_ready=None,\ntimeout=None,\nmetadata=None):\nreturn grpc.experimental.unary_unary(request, target, '/frequenz.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\noptions, channel_credentials,\ninsecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n@staticmethod\ndef DeleteMicrogridDispatch(request,\ntarget,\noptions=(),\nchannel_credentials=None,\ncall_credentials=None,\ninsecure=False,\ncompression=None,\nwait_for_ready=None,\ntimeout=None,\nmetadata=None):\nreturn grpc.experimental.unary_unary(request, target, '/frequenz.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\nfrequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\ngoogle_dot_protobuf_dot_empty__pb2.Empty.FromString,\noptions, channel_credentials,\ninsecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub","title":"<code>frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub</code>","text":"<p>Service providing operations related to dispatching microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def add_MicrogridDispatchServiceServicer_to_server(servicer, server):\nrpc_method_handlers = {\n'ListMicrogridDispatches': grpc.unary_unary_rpc_method_handler(\nservicer.ListMicrogridDispatches,\nrequest_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.FromString,\nresponse_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.SerializeToString,\n),\n'CreateMicrogridDispatch': grpc.unary_unary_rpc_method_handler(\nservicer.CreateMicrogridDispatch,\nrequest_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.FromString,\nresponse_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n),\n'UpdateMicrogridDispatch': grpc.unary_unary_rpc_method_handler(\nservicer.UpdateMicrogridDispatch,\nrequest_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.FromString,\nresponse_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n),\n'GetMicrogridDispatch': grpc.unary_unary_rpc_method_handler(\nservicer.GetMicrogridDispatch,\nrequest_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.FromString,\nresponse_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.SerializeToString,\n),\n'DeleteMicrogridDispatch': grpc.unary_unary_rpc_method_handler(\nservicer.DeleteMicrogridDispatch,\nrequest_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.FromString,\nresponse_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n),\n}\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.CreateMicrogridDispatch","title":"<code>CreateMicrogridDispatch: grpc.aio.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.DeleteMicrogridDispatch","title":"<code>DeleteMicrogridDispatch: grpc.aio.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.GetMicrogridDispatch","title":"<code>GetMicrogridDispatch: grpc.aio.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest, frequenz.dispatch.v1.dispatch_pb2.Dispatch]</code>  <code>instance-attribute</code>","text":"<p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.ListMicrogridDispatches","title":"<code>ListMicrogridDispatches: grpc.aio.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest, frequenz.dispatch.v1.dispatch_pb2.DispatchList]</code>  <code>instance-attribute</code>","text":"<p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceAsyncStub.UpdateMicrogridDispatch","title":"<code>UpdateMicrogridDispatch: grpc.aio.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Update a dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer","title":"<code>frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer</code>","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceServicer(object):\n\"\"\"Service providing operations related to dispatching microgrid components.\n    \"\"\"\ndef ListMicrogridDispatches(self, request, context):\n\"\"\"Returns a list of all dispatches\n        \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\ndef CreateMicrogridDispatch(self, request, context):\n\"\"\"Create a new dispatch\n        \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\ndef UpdateMicrogridDispatch(self, request, context):\n\"\"\"Update a dispatch\n        \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\ndef GetMicrogridDispatch(self, request, context):\n\"\"\"Get a single dispatch\n        \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\ndef DeleteMicrogridDispatch(self, request, context):\n\"\"\"Delete a given dispatch\n        \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.CreateMicrogridDispatch","title":"<code>CreateMicrogridDispatch(request, context)</code>","text":"<p>Create a new dispatch</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def CreateMicrogridDispatch(self, request, context):\n\"\"\"Create a new dispatch\n    \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.DeleteMicrogridDispatch","title":"<code>DeleteMicrogridDispatch(request, context)</code>","text":"<p>Delete a given dispatch</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def DeleteMicrogridDispatch(self, request, context):\n\"\"\"Delete a given dispatch\n    \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.GetMicrogridDispatch","title":"<code>GetMicrogridDispatch(request, context)</code>","text":"<p>Get a single dispatch</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def GetMicrogridDispatch(self, request, context):\n\"\"\"Get a single dispatch\n    \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.ListMicrogridDispatches","title":"<code>ListMicrogridDispatches(request, context)</code>","text":"<p>Returns a list of all dispatches</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def ListMicrogridDispatches(self, request, context):\n\"\"\"Returns a list of all dispatches\n    \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceServicer.UpdateMicrogridDispatch","title":"<code>UpdateMicrogridDispatch(request, context)</code>","text":"<p>Update a dispatch</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def UpdateMicrogridDispatch(self, request, context):\n\"\"\"Update a dispatch\n    \"\"\"\ncontext.set_code(grpc.StatusCode.UNIMPLEMENTED)\ncontext.set_details('Method not implemented!')\nraise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub","title":"<code>frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub</code>","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to dispatching microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>class MicrogridDispatchServiceStub(object):\n\"\"\"Service providing operations related to dispatching microgrid components.\n    \"\"\"\ndef __init__(self, channel):\n\"\"\"Constructor.\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\nself.ListMicrogridDispatches = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\nresponse_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\n)\nself.CreateMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\nself.UpdateMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\nself.GetMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\nresponse_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\n)\nself.DeleteMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\n</code></pre>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.CreateMicrogridDispatch","title":"<code>CreateMicrogridDispatch: grpc.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchCreateRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch', request_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Create a new dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.DeleteMicrogridDispatch","title":"<code>DeleteMicrogridDispatch: grpc.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchDeleteRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch', request_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Delete a given dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.GetMicrogridDispatch","title":"<code>GetMicrogridDispatch: grpc.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchGetRequest, frequenz.dispatch.v1.dispatch_pb2.Dispatch] = channel.unary_unary('/frequenz.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch', request_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString, response_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString)</code>  <code>instance-attribute</code>","text":"<p>Get a single dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.ListMicrogridDispatches","title":"<code>ListMicrogridDispatches: grpc.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchListRequest, frequenz.dispatch.v1.dispatch_pb2.DispatchList] = channel.unary_unary('/frequenz.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches', request_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString, response_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a list of all dispatches</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.UpdateMicrogridDispatch","title":"<code>UpdateMicrogridDispatch: grpc.UnaryUnaryMultiCallable[frequenz.dispatch.v1.dispatch_pb2.DispatchUpdateRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch', request_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Update a dispatch</p>"},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/dispatch/v1/dispatch_pb2_grpc/#frequenz.dispatch.v1.dispatch_pb2_grpc.MicrogridDispatchServiceStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/dispatch/v1/dispatch_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n\"\"\"Constructor.\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\nself.ListMicrogridDispatches = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/ListMicrogridDispatches',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchListRequest.SerializeToString,\nresponse_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchList.FromString,\n)\nself.CreateMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/CreateMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchCreateRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\nself.UpdateMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/UpdateMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchUpdateRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\nself.GetMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/GetMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchGetRequest.SerializeToString,\nresponse_deserializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.Dispatch.FromString,\n)\nself.DeleteMicrogridDispatch = channel.unary_unary(\n'/frequenz.dispatch.v1.MicrogridDispatchService/DeleteMicrogridDispatch',\nrequest_serializer=frequenz_dot_dispatch_dot_v1_dot_dispatch__pb2.DispatchDeleteRequest.SerializeToString,\nresponse_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n)\n</code></pre>"}]}